<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://deadmanoz.xyz</id>
    <title>deadmanoz.xyz</title>
    <updated>2025-12-04T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <author>
        <name>deadmanoz</name>
        <uri>https://deadmanoz.xyz</uri>
    </author>
    <link rel="alternate" href="https://deadmanoz.xyz"/>
    <link rel="self" href="https://deadmanoz.xyz/atom.xml"/>
    <subtitle>deadmanoz's website</subtitle>
    <logo>https://deadmanoz.xyz/favicon/apple-touch-icon.png</logo>
    <icon>https://deadmanoz.xyz/favicon/favicon.ico</icon>
    <rights>© 2025 deadmanoz</rights>
    <entry>
        <title type="html"><![CDATA[P2MS Data Carry Part 2: UTXO set analysis]]></title>
        <id>https://deadmanoz.xyz/posts/p2ms-data-carry-2</id>
        <link href="https://deadmanoz.xyz/posts/p2ms-data-carry-2"/>
        <updated>2025-12-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Exploring P2MS for data carriage in a snapshot of the UTXO set]]></summary>
        <content type="html"><![CDATA[<h2 id="tldr">tl;dr</h2>
<p>Analysis of 2.42 million P2MS UTXOs at block height 918,997 (October 2025) reveals that P2MS has been almost entirely co-opted for data carriage rather than its intended multisig purpose.
Over 99.98% of P2MS outputs serve data embedding protocols, with only 0.02% (552 outputs) appearing to be legitimate multisig usage.</p>
<p>Bitcoin Stamps dominates with 73.57% of all P2MS outputs, followed by Counterparty (22.86%) and Omni Layer (1.78%).
Unlike Bitcoin Stamps, both Counterparty and Omni maintain at least one valid public key per output, preserving spendability.</p>
<p>Spendability analysis reveals that 74.37% of all P2MS outputs are unspendable, with Bitcoin Stamps responsible for 98.9% of these through deliberate use of fake public keys.
Only 10.6% of P2MS outputs ever created have been spent.
The historical trend is stark: outputs created before 2023 were predominantly spendable (>95%), while those created since Bitcoin Stamps launched in early 2023 are ~99.5% unspendable.</p>
<p>The value distribution is notably inverted: unspendable outputs contain only 20.54% of the total value (~14.3 BTC), while ~55.2 BTC in spendable outputs remains theoretically recoverable.
Only 69.47 BTC is locked in P2MS outputs in total, just 0.00035% of total supply, yet users have paid over 281 BTC in fees to embed this data.</p>
<p>Content analysis shows that JSON data is present in 72.64% of all P2MS outputs, driven by Bitcoin Stamps' SRC-20, SRC-721, and SRC-101 sub-protocols.
Notably, Bitcoin Stamps hasn't created any "Classic Stamps" (images), the original motivation for unspendable P2MS outputs, since March 2024, with current usage entirely JSON-based.
All told, P2MS data carriage has left a 252.2 MB footprint (~2.2% of total UTXO set size).</p>
<p>With Bitcoin Core v30.0 (October 2025) removing <code>OP_RETURN</code> size limits, Bitcoin Stamps now has a viable alternative for its JSON payloads that doesn't impose permanent costs on the network.
Bitcoin Stamps' original rationale, UTXO set permanence for art, no longer applies when the protocol is embedding only JSON.
Combined with P2MS being almost entirely unused for its intended multisig purpose, there is now a reasonable case for deprecating P2MS output creation entirely.</p>
<h2 id="introduction">Introduction</h2>
<p>The post follows on from <a href="./p2ms-data-carry-1">P2MS Data Carry Part 1: Fundamentals and Examples</a>, which explored the technical mechanics of how Bitcoin Stamps, Counterparty, Omni, and other protocols embed arbitrary data into Pay-to-Multisig (P2MS) transaction outputs.
This post shifts focus to analysing a recent snapshot of the UTXO set to examine how P2MS has been used for data carriage by these protocols, quantify the magnitude of each protocol's contribution to the UTXO set and generally examine various facets of the use of P2MS.</p>
<p>There is perhaps an unnecessary level of detail in some of the sections below; this is in recognition of the fact that the content will (primarily?) be scraped and re-presented by LLMs and AI tools.
The more context and detail, the better, in our brave new world.</p>
<h3 id="data-and-methodology">Data and methodology</h3>
<p>The following analysis is based on a snapshot of the UTXO set at block height <a href="https://mempool.space/block/00000000000000000000bd33bb70d3d9f967b25bddc254ec4bf05655adba119e">918,997</a> (14 October 2025).
A UTXO set snapshot was used rather than full blockchain history because around 90% of all P2MS outputs ever created have never been spent, with very little spending activity in recent times.</p>
<p>The UTXO set was dumped using the <a href="https://github.com/in3rsha/bitcoin-utxo-dump"><code>bitcoin-utxo-dump</code></a> tool, and then processed using the code of the <a href="https://github.com/deadmanoz/data-carry-research"><code>data-carry-research</code></a> companion repository.
Note that the UTXO set as dumped using the <a href="https://github.com/in3rsha/bitcoin-utxo-dump"><code>bitcoin-utxo-dump</code></a> tool generates a CSV that is ~31GB at the time of <del>writing</del> dumping (block height <a href="https://mempool.space/block/00000000000000000000bd33bb70d3d9f967b25bddc254ec4bf05655adba119e">918,997</a>, 14 October 2025).
Note that the findings in this post are fully reproducible by using the <a href="https://github.com/in3rsha/bitcoin-utxo-dump"><code>bitcoin-utxo-dump</code></a> and <a href="https://github.com/deadmanoz/data-carry-research"><code>data-carry-research</code></a> tools.</p>
<h3 id="protocol-classification">Protocol classification</h3>
<p>The <a href="https://github.com/deadmanoz/data-carry-research"><code>data-carry-research</code></a> tool identifies and classifies P2MS outputs into the following categories:</p>
<table>
<thead>
<tr>
<th>Classification</th>
<th>Detection Method</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bitcoin Stamps</strong></td>
<td>ARC4-obfuscated message analysis with <code>stamp:</code> (or variant) prefix</td>
</tr>
<tr>
<td><strong>Counterparty</strong></td>
<td>ARC4-obfuscated message analysis with <code>CNTRPRTY</code> prefix</td>
</tr>
<tr>
<td><strong>Omni Layer</strong></td>
<td>Presence of Exodus address (<a href="https://mempool.space/address/1EXoDusjGwvnjZUyKkxZ4UHEf77z6A5S4P"><code>1EXoDusj...</code></a>) as transaction output</td>
</tr>
<tr>
<td><strong>Chancecoin</strong></td>
<td><code>CHANCECO</code> identifier present in ASCII interpretation of P2MS outputs</td>
</tr>
<tr>
<td><strong>PPk</strong></td>
<td>Marker pubkey detection (<code>0320a0de...3e12</code>)</td>
</tr>
<tr>
<td><strong>ASCII Identifier Protocols</strong></td>
<td>Unobfuscated ASCII identifiers in P2MS outputs (e.g., <code>TB0001</code>, <code>TEST01</code>, <code>METROXMN</code>)</td>
</tr>
<tr>
<td><strong>OP_RETURN Signalled</strong></td>
<td>Protocol identifiers present in accompanying <code>OP_RETURN</code> outputs</td>
</tr>
<tr>
<td><strong>Data Storage</strong></td>
<td>Pattern matching for known data (WikiLeaks Cablegate, Bitcoin whitepaper) and file signatures</td>
</tr>
<tr>
<td><strong>Likely Data Storage</strong></td>
<td>Heuristic-based: dust-level values, high output counts, or invalid EC points</td>
</tr>
<tr>
<td><strong>Likely Legitimate Multisig</strong></td>
<td>All valid EC points, reasonable values, no protocol markers</td>
</tr>
</tbody>
</table>
<p><strong>Table 1:</strong> Classification methodology</p>
<p>Protocols are checked in a specific precedence order to avoid misclassification.
This ordering is important because some protocols use others as transport mechanisms, e.g., early Bitcoin Stamps transactions used Counterparty as a transport layer, requiring Bitcoin Stamps detection to occur before Counterparty classification.</p>
<h2 id="analysing-p2ms-utxos">Analysing P2MS UTXOs</h2>
<p>The snapshot of the UTXO set at block height <a href="https://mempool.space/block/00000000000000000000bd33bb70d3d9f967b25bddc254ec4bf05655adba119e">918,997</a> (14 October 2025) contains 2,423,456 P2MS transaction outputs created between block height 170,741 (transaction <a href="https://mempool.space/tx/947539645c59e6ab0cda61826cbacb55ef97a8178f012f8c18abe504bf66d4ce"><code>94753964...</code></a>) through to the snapshot height, across 1,330,493 transactions.
The ~2.4M P2MS transaction outputs account for 1.46% of the total transaction outputs in the UTXO set (166,127,819), yet only 0.00034851% of the total Bitcoin supply is encumbered in P2MS outputs (69.47467961 BTC).
Table 2 summarises some of the various high-level stats pertaining to P2MS outputs as of block height <a href="https://mempool.space/block/00000000000000000000bd33bb70d3d9f967b25bddc254ec4bf05655adba119e">918,997</a>.</p>
<table>
<thead>
<tr>
<th>Metric</th>
<th align="right">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td># of unspent P2MS outputs</td>
<td align="right">2,423,456</td>
</tr>
<tr>
<td># of unspent total outputs</td>
<td align="right">166,127,819</td>
</tr>
<tr>
<td>P2MS % of total outputs</td>
<td align="right">1.46%</td>
</tr>
<tr>
<td># of transactions unspent P2MS outputs come from</td>
<td align="right">1,330,493</td>
</tr>
<tr>
<td>Value of P2MS outputs</td>
<td align="right">69.47467961 BTC</td>
</tr>
<tr>
<td>Total BTC supply</td>
<td align="right">19,934,368.75 BTC</td>
</tr>
<tr>
<td>P2MS % of total supply</td>
<td align="right">0.00034851%</td>
</tr>
<tr>
<td>Average value P2MS output</td>
<td align="right">0.00002867 BTC per output (2,867 sats)</td>
</tr>
<tr>
<td>Minimum value P2MS output</td>
<td align="right">0.00000001 BTC (1 sat)</td>
</tr>
<tr>
<td>Maximum value P2MS output</td>
<td align="right">1.85690258 BTC</td>
</tr>
</tbody>
</table>
<p><strong>Table 2:</strong> High-level P2MS stats as of block height 918,997 (14 October 2025).</p>
<blockquote>
<p><strong>Only 0.00035% of the total Bitcoin supply is encumbered in P2MS outputs (~69.5 BTC).</strong></p>
</blockquote>
<h3 id="top-level-classification-breakdown">Top-level classification breakdown</h3>
<p>Table 3 presents a classification breakdown of the P2MS transaction outputs.
The combined contribution of the three dominant protocols in Bitcoin Stamps, Counterparty and Omni, is 98.21% of all P2MS outputs.
If we include the other data carrying classifications of Chancecoin, PPk, OP_RETURN Signalled, ASCII Identifier Protocols, Data Storage and Likely Data Storage, then this value rises to 99.98%.
The remaining 0.02% represents what appears to be Likely Legitimate Multisig usage rather than data carriage.</p>
<blockquote>
<p><strong>Approximately 99.98% of all P2MS transaction outputs in the UTXO set are used for data carrying purposes.</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>Protocol/Use</th>
<th align="right">Transactions</th>
<th align="right">P2MS Outputs</th>
<th align="right">% of Total P2MS Outputs</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitcoin Stamps</td>
<td align="right">969,868</td>
<td align="right">1,782,916</td>
<td align="right">73.57%</td>
</tr>
<tr>
<td>Counterparty</td>
<td align="right">303,677</td>
<td align="right">553,981</td>
<td align="right">22.86%</td>
</tr>
<tr>
<td>Omni Layer</td>
<td align="right">40,571</td>
<td align="right">43,077</td>
<td align="right">1.78%</td>
</tr>
<tr>
<td>Data Storage</td>
<td align="right">5,273</td>
<td align="right">28,831</td>
<td align="right">1.19%</td>
</tr>
<tr>
<td>Chancecoin</td>
<td align="right">2,647</td>
<td align="right">5,051</td>
<td align="right">0.21%</td>
</tr>
<tr>
<td>PPk</td>
<td align="right">4,706</td>
<td align="right">4,728</td>
<td align="right">0.20%</td>
</tr>
<tr>
<td>Likely Data Storage</td>
<td align="right">1,208</td>
<td align="right">2,152</td>
<td align="right">0.09%</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td align="right">1,342</td>
<td align="right">1,352</td>
<td align="right">0.06%</td>
</tr>
<tr>
<td>ASCII Identifier Protocols</td>
<td align="right">677</td>
<td align="right">816</td>
<td align="right">0.03%</td>
</tr>
<tr>
<td>Likely Legitimate Multisig</td>
<td align="right">524</td>
<td align="right">552</td>
<td align="right">0.02%</td>
</tr>
</tbody>
</table>
<p><strong>Table 3:</strong> Classification breakdown of P2MS outputs as of block height 918,997 (14 October 2025).</p>
<blockquote>
<p><strong>Bitcoin Stamps dominates unspent P2MS outputs, accounting for 73.57% of all such outputs.</strong></p>
</blockquote>
<p>Table 4 presents a breakdown by value encumbered in P2MS outputs.
Despite Bitcoin Stamps dominating by output count (73.57%), Counterparty leads by value with 35.87 BTC (51.6%) across its 553,981 outputs.
Bitcoin Stamps, with nearly four times as many outputs, holds only 14.19 BTC (20.4%) due to its dust-level output values.
The distribution of output value is examined in the <a href="#value-distribution">UTXO value breakdown section</a>.</p>
<table>
<thead>
<tr>
<th>Protocol/Use</th>
<th align="right">Outputs</th>
<th align="right">Total BTC</th>
<th align="right">Avg BTC/Output</th>
<th align="right">Min BTC</th>
<th align="right">Max BTC</th>
</tr>
</thead>
<tbody>
<tr>
<td>Counterparty</td>
<td align="right">553,981</td>
<td align="right">35.86506687</td>
<td align="right">0.00006474</td>
<td align="right">0.00000625</td>
<td align="right">0.38732200</td>
</tr>
<tr>
<td>Bitcoin Stamps</td>
<td align="right">1,782,916</td>
<td align="right">14.18754855</td>
<td align="right">0.00000796</td>
<td align="right">0.00000546</td>
<td align="right">0.00007800</td>
</tr>
<tr>
<td>Data Storage</td>
<td align="right">28,831</td>
<td align="right">10.18052541</td>
<td align="right">0.00035311</td>
<td align="right">0.00000001</td>
<td align="right">1.85690258</td>
</tr>
<tr>
<td>Likely Legitimate Multisig</td>
<td align="right">552</td>
<td align="right">6.49722937</td>
<td align="right">0.01177034</td>
<td align="right">0.00001004</td>
<td align="right">1.00916635</td>
</tr>
<tr>
<td>Omni Layer</td>
<td align="right">43,077</td>
<td align="right">2.32399710</td>
<td align="right">0.00005395</td>
<td align="right">0.00000007</td>
<td align="right">0.11066900</td>
</tr>
<tr>
<td>Chancecoin</td>
<td align="right">5,051</td>
<td align="right">0.15158820</td>
<td align="right">0.00003001</td>
<td align="right">0.00000780</td>
<td align="right">0.00010860</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td align="right">1,352</td>
<td align="right">0.10793465</td>
<td align="right">0.00007983</td>
<td align="right">0.00000013</td>
<td align="right">0.00084570</td>
</tr>
<tr>
<td>ASCII Identifier Protocols</td>
<td align="right">816</td>
<td align="right">0.07778934</td>
<td align="right">0.00009533</td>
<td align="right">0.00000780</td>
<td align="right">0.00130000</td>
</tr>
<tr>
<td>PPk</td>
<td align="right">4,728</td>
<td align="right">0.04827642</td>
<td align="right">0.00001021</td>
<td align="right">0.00001000</td>
<td align="right">0.00005757</td>
</tr>
<tr>
<td>Likely Data Storage</td>
<td align="right">2,152</td>
<td align="right">0.03472370</td>
<td align="right">0.00001614</td>
<td align="right">0.00000001</td>
<td align="right">0.00303350</td>
</tr>
</tbody>
</table>
<p><strong>Table 4:</strong> Value by classification breakdown of P2MS outputs as of block height 918,997 (14 October 2025).</p>
<blockquote>
<p><strong>The average value of Bitcoin Stamps classified P2MS outputs is just 796 sats.</strong></p>
</blockquote>
<h3 id="multisig-configuration-breakdown">Multisig configuration breakdown</h3>
<h4 id="standardness-rules">Standardness rules</h4>
<p>P2MS supports up to n=3 public keys for <strong>standard</strong> m-of-n multisig configurations (where m≤n).
However, <a href="https://bitcoin.stackexchange.com/questions/23893/what-are-the-limits-of-m-and-n-in-m-of-n-multisig-addresses">consensus rules</a> allow for any m-of-n combination where 1≤m≤n≤20.
That is, m-of-n combinations outside of the <strong>standard</strong> multisig range are considered <strong>non-standard</strong> by policy, failing Bitcoin Core's <code>IsStandard</code> evaluation (see <a href="https://github.com/bitcoin/bitcoin/blob/439e58c4d8194ca37f70346727d31f52e69592ec/src/policy/policy.cpp#L53-L74">policy.cpp</a>):</p>
<pre><code class="hljs language-c++"><span class="hljs-comment">// Support up to x-of-3 multisig txns as standard</span>
<span class="hljs-keyword">if</span> (n &#x3C; <span class="hljs-number">1</span> || n > <span class="hljs-number">3</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
<span class="hljs-keyword">if</span> (m &#x3C; <span class="hljs-number">1</span> || m > n)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
<span class="hljs-comment">///</span>
</code></pre>
<p>The classification produced by the <a href="https://github.com/in3rsha/bitcoin-utxo-dump/blob/9b1c015308f779ac529083ed7922cc551b8ddb53/utxodump.go#L514-L522"><code>bitcoin-utxo-dump</code></a> tool is more permissive than that of Bitcoin Core (see snippet from <code>bitcoin-utxo-dump</code> below).
Specifically, non-standard scripts that are at least 37 bytes in length and end with the <code>OP_CHECKMULTISIG</code> opcode are marked as <code>multisig</code> (P2MS).
This, however, does not pose a significant discrepancy - only 48 UTXOs match this criteria in the analysed UTXO set snapshot.</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// P2MS</span>
<span class="hljs-comment">// if there is a script, it's at least 37 bytes in length (min size for a P2MS)</span>
<span class="hljs-comment">// and if the last opcode is OP_CHECKMULTISIG (174) (0xae)</span>
<span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(script) >= <span class="hljs-number">37</span> &#x26;&#x26; script[<span class="hljs-built_in">len</span>(script)<span class="hljs-number">-1</span>] == <span class="hljs-number">174</span>: 
    scriptType = <span class="hljs-string">"p2ms"</span>
    scriptTypeCount[<span class="hljs-string">"p2ms"</span>] += <span class="hljs-number">1</span>

<span class="hljs-comment">// Non-Standard</span>
(<span class="hljs-keyword">if</span> the script <span class="hljs-keyword">type</span> hasn<span class="hljs-string">'t been identified and set then it remains as an unknown "non-standard" script)
default:
  scriptType = "non-standard"
    scriptTypeCount["non-standard"] += 1
</span></code></pre>
<h4 id="observed-configurations">Observed configurations</h4>
<p>Table 5 shows the prevalence of different multisig configurations in the P2MS outputs in the UTXO set at the analysis block height.</p>
<table>
<thead>
<tr>
<th>Multisig Configuration</th>
<th align="right">Count</th>
<th align="right">Percentage</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-of-3</td>
<td align="right">2,213,925</td>
<td align="right">91.35%</td>
</tr>
<tr>
<td>1-of-2</td>
<td align="right">204,619</td>
<td align="right">8.44%</td>
</tr>
<tr>
<td>2-of-2</td>
<td align="right">3,262</td>
<td align="right">0.13%</td>
</tr>
<tr>
<td>1-of-1</td>
<td align="right">1,121</td>
<td align="right">0.05%</td>
</tr>
<tr>
<td>2-of-3</td>
<td align="right">509</td>
<td align="right">0.02%</td>
</tr>
<tr>
<td>3-of-3</td>
<td align="right">20</td>
<td align="right">0.0%</td>
</tr>
</tbody>
</table>
<p><strong>Table 5:</strong> Prevalence of different multisig configurations observed in the UTXO set of block height 918,997 (14 October 2025).</p>
<p>The 1-of-3 multisig configuration dominates, accounting for 2,213,925 outputs or 91.35% of all P2MS outputs in the UTXO set.
This dominance is almost entirely attributable to Bitcoin Stamps, which exclusively uses 1-of-3 configurations, though Counterparty and Data Storage also favour 1-of-3.</p>
<p>The 1-of-2 multisig configuration accounts for 8.44%, largely due to Counterparty.
90.16% of Omni P2MS outputs use 1-of-2, and Chancecoin exclusively uses this configuration.</p>
<p>The remaining configurations are marginal: 2-of-2 represents just 0.13% (3,262 outputs), while 1-of-1, 2-of-3, and 3-of-3 collectively account for less than 0.1% of the UTXO set.
Table 6 gives the full breakdown by protocol.</p>
<p><strong>TABLE: Multisig configuration by protocol breakdown</strong></p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Multisig Type</th>
<th align="right">Outputs</th>
<th align="right">% of Protocol</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitcoin Stamps</td>
<td>1-of-3</td>
<td align="right">1,782,916</td>
<td align="right">100.0%</td>
</tr>
<tr>
<td>Counterparty</td>
<td>1-of-3</td>
<td align="right">399,412</td>
<td align="right">72.1%</td>
</tr>
<tr>
<td>Counterparty</td>
<td>1-of-2</td>
<td align="right">153,930</td>
<td align="right">27.79%</td>
</tr>
<tr>
<td>Counterparty</td>
<td>2-of-2</td>
<td align="right">625</td>
<td align="right">0.11%</td>
</tr>
<tr>
<td>Counterparty</td>
<td>3-of-3</td>
<td align="right">8</td>
<td align="right">0.0%</td>
</tr>
<tr>
<td>Counterparty</td>
<td>2-of-3</td>
<td align="right">6</td>
<td align="right">0.0%</td>
</tr>
<tr>
<td>Omni Layer</td>
<td>1-of-2</td>
<td align="right">38,839</td>
<td align="right">90.16%</td>
</tr>
<tr>
<td>Omni Layer</td>
<td>1-of-3</td>
<td align="right">4,236</td>
<td align="right">9.83%</td>
</tr>
<tr>
<td>Omni Layer</td>
<td>1-of-1</td>
<td align="right">2</td>
<td align="right">0.0%</td>
</tr>
<tr>
<td>Data Storage</td>
<td>1-of-3</td>
<td align="right">23,307</td>
<td align="right">80.84%</td>
</tr>
<tr>
<td>Data Storage</td>
<td>1-of-2</td>
<td align="right">4,590</td>
<td align="right">15.92%</td>
</tr>
<tr>
<td>Data Storage</td>
<td>2-of-2</td>
<td align="right">418</td>
<td align="right">1.45%</td>
</tr>
<tr>
<td>Data Storage</td>
<td>1-of-1</td>
<td align="right">368</td>
<td align="right">1.28%</td>
</tr>
<tr>
<td>Data Storage</td>
<td>2-of-3</td>
<td align="right">137</td>
<td align="right">0.48%</td>
</tr>
<tr>
<td>Data Storage</td>
<td>3-of-3</td>
<td align="right">11</td>
<td align="right">0.04%</td>
</tr>
<tr>
<td>Chancecoin</td>
<td>1-of-2</td>
<td align="right">5,051</td>
<td align="right">100.0%</td>
</tr>
<tr>
<td>PPk</td>
<td>1-of-3</td>
<td align="right">3,330</td>
<td align="right">70.43%</td>
</tr>
<tr>
<td>PPk</td>
<td>1-of-2</td>
<td align="right">1,398</td>
<td align="right">29.57%</td>
</tr>
<tr>
<td>Likely Data Storage</td>
<td>2-of-2</td>
<td align="right">854</td>
<td align="right">39.68%</td>
</tr>
<tr>
<td>Likely Data Storage</td>
<td>1-of-1</td>
<td align="right">697</td>
<td align="right">32.39%</td>
</tr>
<tr>
<td>Likely Data Storage</td>
<td>1-of-3</td>
<td align="right">299</td>
<td align="right">13.89%</td>
</tr>
<tr>
<td>Likely Data Storage</td>
<td>2-of-3</td>
<td align="right">291</td>
<td align="right">13.52%</td>
</tr>
<tr>
<td>Likely Data Storage</td>
<td>1-of-2</td>
<td align="right">11</td>
<td align="right">0.51%</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td>2-of-2</td>
<td align="right">1,137</td>
<td align="right">84.1%</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td>1-of-2</td>
<td align="right">146</td>
<td align="right">10.8%</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td>1-of-3</td>
<td align="right">62</td>
<td align="right">4.59%</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td>2-of-3</td>
<td align="right">5</td>
<td align="right">0.37%</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td>3-of-3</td>
<td align="right">1</td>
<td align="right">0.07%</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td>1-of-1</td>
<td align="right">1</td>
<td align="right">0.07%</td>
</tr>
<tr>
<td>ASCII Identifier Protocols</td>
<td>1-of-2</td>
<td align="right">516</td>
<td align="right">63.24%</td>
</tr>
<tr>
<td>ASCII Identifier Protocols</td>
<td>1-of-3</td>
<td align="right">300</td>
<td align="right">36.76%</td>
</tr>
<tr>
<td>Likely Legitimate Multisig</td>
<td>2-of-2</td>
<td align="right">228</td>
<td align="right">41.30%</td>
</tr>
<tr>
<td>Likely Legitimate Multisig</td>
<td>1-of-2</td>
<td align="right">138</td>
<td align="right">25.00%</td>
</tr>
<tr>
<td>Likely Legitimate Multisig</td>
<td>2-of-3</td>
<td align="right">70</td>
<td align="right">12.68%</td>
</tr>
<tr>
<td>Likely Legitimate Multisig</td>
<td>1-of-3</td>
<td align="right">63</td>
<td align="right">11.41%</td>
</tr>
<tr>
<td>Likely Legitimate Multisig</td>
<td>1-of-1</td>
<td align="right">53</td>
<td align="right">9.60%</td>
</tr>
</tbody>
</table>
<p><strong>Table 6:</strong> Breakdown of multisig configurations by protocol as of block height 918,997 (14 October 2025).</p>
<h3 id="spendability-breakdown">Spendability breakdown</h3>
<p>In the context of P2MS, a spendable output contains at least one valid public key with a known corresponding private key, meaning the output could theoretically be spent to recover the encumbered bitcoin.
An unspendable output either contains no valid public keys or uses keys for which no private key is known to exist (such as Bitcoin Stamps' Key Burn addresses), permanently locking the bitcoin in the UTXO set.</p>
<p>As explored in <a href="./p2ms-data-carry-1#fake-keys">Part 1: Fundamentals and Examples - Fake Keys</a>, we can assess pubkeys to determine if they are invalid.
More specifically, we can check whether a given public key is a valid point on the ECDSA secp256k1 curve. If it is not, we know it is a "fake" public key.
However, if it is on the curve, it could be a true key or just "data" that happens to correspond to a point on the curve.
This property is one component in the analysis of the spendability of the P2MS outputs in the UTXO set.</p>
<p>The other component in this analysis is leveraging what is known about the various protocols that use P2MS outputs.
Again, as covered in <a href="./p2ms-data-carry-1#summarising-the-main-techniques">Part 1: Fundamentals and Examples - Summarising the main techniques</a>, we know that:</p>
<ul>
<li>Bitcoin Stamps exclusively uses Key Burn keys and data keys to ensure unspendability.</li>
<li>Counterparty, Omni and Chancecoin maintain at least one valid public key per output, ensuring spendability and avoiding permanent UTXO set pollution.</li>
</ul>
<p>Combining these two components, we can classify P2MS outputs as either spendable or unspendable.</p>
<p>Table 7 presents the top-level spendability breakdown.
Of the 2.4M P2MS outputs in the UTXO set, 1.8M (74.37%) are unspendable and will remain in the UTXO set forever.</p>
<table>
<thead>
<tr>
<th>Status</th>
<th align="right">Count</th>
<th align="right">% of Outputs</th>
<th align="right">Total BTC</th>
<th align="right">% of BTC Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spendable</td>
<td align="right">621,202</td>
<td align="right">25.63%</td>
<td align="right">55.20673574</td>
<td align="right">79.46%</td>
</tr>
<tr>
<td>Unspendable</td>
<td align="right">1,802,254</td>
<td align="right">74.37%</td>
<td align="right">14.26794387</td>
<td align="right">20.54%</td>
</tr>
</tbody>
</table>
<p><strong>Table 7:</strong> Spendability breakdown of P2MS outputs in the UTXO set, as of block height 918,997 (14 October 2025).</p>
<p>Notably, the value distribution is inverted: although 74.37% of outputs are unspendable, they contain only 20.54% of the total BTC value (~14.3 BTC).
The remaining 79.46% of value (~55.2 BTC) resides in spendable outputs.
This inversion occurs because Bitcoin Stamps outputs use minimal dust-level amounts (546-1000 sats), while legitimate multisig and older Counterparty/Omni transactions encumber higher amounts.</p>
<blockquote>
<p><strong>~79.5% of the total value of P2MS outputs is spendable (~55.2 BTC), only 20.5% (~14.3 BTC) is unspendable.</strong></p>
</blockquote>
<p>Table 8 breaks down spendability by protocol.
Bitcoin Stamps is responsible for 1,782,916 (98.9%) of the unspendable P2MS outputs in the UTXO set.
In contrast, Counterparty, Omni, Chancecoin, PPk, and legitimate multisig outputs are 100% spendable.</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th align="right">Spendable</th>
<th align="right">Unspendable</th>
<th align="right">% Spendable</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitcoin Stamps</td>
<td align="right">0</td>
<td align="right">1,782,916</td>
<td align="right">0.00%</td>
</tr>
<tr>
<td>Counterparty</td>
<td align="right">553,981</td>
<td align="right">0</td>
<td align="right">100.00%</td>
</tr>
<tr>
<td>Omni Layer</td>
<td align="right">43,077</td>
<td align="right">0</td>
<td align="right">100.00%</td>
</tr>
<tr>
<td>Data Storage</td>
<td align="right">9,597</td>
<td align="right">19,234</td>
<td align="right">33.29%</td>
</tr>
<tr>
<td>Chancecoin</td>
<td align="right">5,051</td>
<td align="right">0</td>
<td align="right">100.00%</td>
</tr>
<tr>
<td>PPk</td>
<td align="right">4,728</td>
<td align="right">0</td>
<td align="right">100.00%</td>
</tr>
<tr>
<td>Likely Data Storage</td>
<td align="right">2,149</td>
<td align="right">3</td>
<td align="right">99.86%</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td align="right">1,251</td>
<td align="right">101</td>
<td align="right">92.53%</td>
</tr>
<tr>
<td>ASCII Identifier Protocols</td>
<td align="right">816</td>
<td align="right">0</td>
<td align="right">100.00%</td>
</tr>
<tr>
<td>Likely Legitimate Multisig</td>
<td align="right">552</td>
<td align="right">0</td>
<td align="right">100.00%</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>621,202</strong> (25.63%)</td>
<td align="right"><strong>1,802,254</strong> (74.37%)</td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p><strong>Table 8:</strong> Spendability of P2MS outputs in the UTXO set, separated by protocol classification, as of block height 918,997 (14 October 2025).</p>
<blockquote>
<p><strong>Almost 75% of P2MS outputs in the UTXO set are unspendable, with Bitcoin Stamps responsible for virtually all of them.</strong></p>
</blockquote>
<h4 id="spendability-over-time">Spendability over time</h4>
<p>The 74.37% unspendability figure reflects the accumulated history of P2MS usage since 2012.
However, recent years show an even more pronounced trend: almost all P2MS outputs created since 2023 are unspendable due to Bitcoin Stamps' design.
Figure 1 visualises this dramatic shift.</p>
<p><strong>[Interactive plot - view on website]</strong></p>
<p>P2MS output spendability over time, showing the percentage of spendable (green) vs unspendable (red) outputs created each month. As per the UTXO set as of block height 918,997 (14 October 2025).</p>
<h4 id="spendability-reasons">Spendability reasons</h4>
<p>Breaking down the underlying reasons for spendability provides additional granularity (Table 9):</p>
<table>
<thead>
<tr>
<th>Reason</th>
<th align="right">Count</th>
<th align="right">% of Total</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Unspendable</strong> - Mixed Key Burn and data</td>
<td align="right">1,782,916</td>
<td align="right">73.57%</td>
</tr>
<tr>
<td><strong>Unspendable</strong> - all data keys</td>
<td align="right">19,338</td>
<td align="right">0.80%</td>
</tr>
<tr>
<td><strong>Spendable</strong> - Contains real pubkey</td>
<td align="right">620,650</td>
<td align="right">25.61%</td>
</tr>
<tr>
<td><strong>Spendable</strong> - All valid EC points</td>
<td align="right">552</td>
<td align="right">0.02%</td>
</tr>
</tbody>
</table>
<p><strong>Table 9:</strong> Classified reasons for P2MS UTXO spendability, as of block height 918,997 (14 October 2025).</p>
<p>The "mixed Key Burn and data" classification (73.57%) represents Bitcoin Stamps outputs that deliberately combine Key Burn addresses with data-carrying keys, making them effectively unspendable.
"All data keys" (0.80%) encompasses outputs where all keys are used purely for data carriage with none representing valid, spendable public keys - primarily early Data Storage efforts.
"Contains real pubkey" (25.61%) indicates outputs that include at least one valid public key that could theoretically be used to spend the output, covering Counterparty, Omni, Chancecoin, and PPk transactions.
"All valid EC points" (0.02%) represents outputs where all keys are valid points on the ECDSA secp256k1 curve, suggesting legitimate multisig usage.</p>
<h3 id="utxo-age-distribution">UTXO age distribution</h3>
<p>In considering the block height at which each unspent P2MS output was created alongside the protocol classification, we can plot the age distribution as per Figure 2.
This groups the age by month and shows annotations for when:</p>
<ul>
<li>P2MS was made standard (March 2012)</li>
<li>Omni was launched (July 2013)</li>
<li>Counterparty was launched (January 2014)</li>
<li>Bitcoin Stamps was launched (April 2023)</li>
</ul>
<p><strong>[Interactive plot - view on website]</strong></p>
<p>Distribution of the age (per-month) of P2MS outputs in the UTXO set, separated by protocol, as of block height 918,997 (14 October 2025).</p>
<p>There are a few interesting observations to be made from this visualisation:</p>
<ul>
<li>We can see the rise and fall in the popularity of Omni (2014-2016)</li>
<li>We can see the rise, fall (2014-2016) and later muted resurgence of Counterparty (2023), with the resurgence likely relating to the launch of Bitcoin Stamps in April 2023.</li>
<li>We can see that in April 2013 there was a peak in Data Storage P2MS outputs, due to both the "WikiLeaks Cablegate" data and the "Bitcoin Whitepaper" being embedded in P2MS outputs in this month.</li>
</ul>
<h3 id="data-content-type-breakdown">Data content type breakdown</h3>
<p>With support for the detection, deobfuscation, parsing and interpretation of various protocols implemented in <a href="https://github.com/deadmanoz/data-carry-research"><code>data-carry-research</code></a>, we can consider the type of data that is embedded in P2MS UTXOs.
Table 10 shows the distribution of detected content types across P2MS transactions and outputs.</p>
<table>
<thead>
<tr>
<th>Content Type</th>
<th align="right">Transactions</th>
<th align="right">% of total transactions</th>
<th align="right">Outputs</th>
<th align="right">% of total outputs</th>
</tr>
</thead>
<tbody>
<tr>
<td>application/json</td>
<td align="right">966,455</td>
<td align="right">72.64%</td>
<td align="right">1,708,561</td>
<td align="right">71.83%</td>
</tr>
<tr>
<td>application/octet-stream</td>
<td align="right">353,953</td>
<td align="right">26.60%</td>
<td align="right">590,289</td>
<td align="right">24.82%</td>
</tr>
<tr>
<td>image/png</td>
<td align="right">3,343</td>
<td align="right">0.25%</td>
<td align="right">49,806</td>
<td align="right">2.09%</td>
</tr>
<tr>
<td>image/svg+xml</td>
<td align="right">133</td>
<td align="right">0.01%</td>
<td align="right">9,681</td>
<td align="right">0.41%</td>
</tr>
<tr>
<td>image/gif</td>
<td align="right">603</td>
<td align="right">0.05%</td>
<td align="right">9,610</td>
<td align="right">0.40%</td>
</tr>
<tr>
<td>text/plain</td>
<td align="right">3,018</td>
<td align="right">0.23%</td>
<td align="right">4,105</td>
<td align="right">0.17%</td>
</tr>
<tr>
<td>image/jpeg</td>
<td align="right">60</td>
<td align="right">&#x3C;0.01%</td>
<td align="right">2,634</td>
<td align="right">0.11%</td>
</tr>
<tr>
<td>application/zlib</td>
<td align="right">1,062</td>
<td align="right">0.08%</td>
<td align="right">2,144</td>
<td align="right">0.09%</td>
</tr>
<tr>
<td>text/html</td>
<td align="right">25</td>
<td align="right">&#x3C;0.01%</td>
<td align="right">1,035</td>
<td align="right">0.04%</td>
</tr>
<tr>
<td>image/webp</td>
<td align="right">19</td>
<td align="right">&#x3C;0.01%</td>
<td align="right">530</td>
<td align="right">0.02%</td>
</tr>
<tr>
<td>image/bmp</td>
<td align="right">25</td>
<td align="right">&#x3C;0.01%</td>
<td align="right">151</td>
<td align="right">0.01%</td>
</tr>
<tr>
<td>text/x-python</td>
<td align="right">1</td>
<td align="right">&#x3C;0.01%</td>
<td align="right">23</td>
<td align="right">&#x3C;0.01%</td>
</tr>
<tr>
<td>text/javascript</td>
<td align="right">2</td>
<td align="right">&#x3C;0.01%</td>
<td align="right">14</td>
<td align="right">&#x3C;0.01%</td>
</tr>
<tr>
<td>application/gzip</td>
<td align="right">1</td>
<td align="right">&#x3C;0.01%</td>
<td align="right">2</td>
<td align="right">&#x3C;0.01%</td>
</tr>
</tbody>
</table>
<p><strong>Table 10:</strong> Content type distribution across P2MS transactions and outputs as of block height 918,997 (14 October 2025).</p>
<p>Takeaways from this breakdown include:</p>
<ul>
<li>The dominant content type is <code>application/json</code> (~72%), primarily from the "SRC-20", "SRC-721", and "SRC-101" sub-protocols of Bitcoin Stamps, all of which use JSON-formatted messages.</li>
<li>Raw binary data (<code>application/octet-stream</code>) accounts for ~25%, representing binary data formats like Counterparty, Omni Layer, Chancecoin and PPk.</li>
<li>Plain text (<code>text/plain</code>) represents less than 0.25%, encompassing human-readable messages embedded in P2MS outputs.</li>
<li>Image formats (<code>image/png</code>, <code>image/svg+xml</code>, <code>image/gif</code>, <code>image/jpeg</code>, <code>image/webp</code>, <code>image/bmp</code>) show significant divergence between transaction and output counts.
PNG images appear in only 3,343 transactions yet span 49,806 outputs, reflecting how images are encoded across many P2MS outputs per transaction.
Collectively, image formats represent approximately 3% of outputs but only 0.31% of transactions.</li>
</ul>
<h3 id="data-size-breakdown">Data size breakdown</h3>
<p>Given the commentary that appears whenever discussing the UTXO set, another natural question to ask about the P2MS outputs is "what is the data size of the P2MS outputs"?
At the highest level, we can answer this question by simply considering the full size of each P2MS script.
For example, a "typical" 1-of-3 P2MS output script with 33-byte compressed public keys has a size of 105 bytes:</p>
<ul>
<li><code>OP_1</code> - 1 byte</li>
<li><code>OP_PUSHBYTES_33 &#x3C;33-byte pubkey></code> - 1 + 33 bytes</li>
<li><code>OP_PUSHBYTES_33 &#x3C;33-byte pubkey></code> - 1 + 33 bytes</li>
<li><code>OP_PUSHBYTES_33 &#x3C;33-byte pubkey></code> - 1 + 33 bytes</li>
<li><code>OP_3</code> - 1 byte</li>
<li><code>OP_CHECKMULTISIG</code> - 1 byte</li>
</ul>
<p>1 + 33 + 1 + 33 + 1 + 33 + 1 + 1 = 105 bytes.</p>
<table>
<thead>
<tr>
<th>M-of-N</th>
<th>Keys</th>
<th align="right">Script size</th>
<th align="right">Outputs</th>
<th align="right">Total Data Size</th>
<th align="right">% of Total</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-of-3</td>
<td>CCC</td>
<td align="right">105 B</td>
<td align="right">2,123,648</td>
<td align="right">223.0 MB</td>
<td align="right">87.63%</td>
</tr>
<tr>
<td>1-of-2</td>
<td>CC</td>
<td align="right">71 B</td>
<td align="right">177,783</td>
<td align="right">12.6 MB</td>
<td align="right">7.34%</td>
</tr>
<tr>
<td>1-of-3</td>
<td>CCU</td>
<td align="right">137 B</td>
<td align="right">73,426</td>
<td align="right">10.1 MB</td>
<td align="right">3.03%</td>
</tr>
<tr>
<td>1-of-3</td>
<td>UUU</td>
<td align="right">201 B</td>
<td align="right">16,835</td>
<td align="right">3.4 MB</td>
<td align="right">0.69%</td>
</tr>
<tr>
<td>1-of-2</td>
<td>CU</td>
<td align="right">103 B</td>
<td align="right">26,690</td>
<td align="right">2.7 MB</td>
<td align="right">1.10%</td>
</tr>
<tr>
<td>2-of-2</td>
<td>CC</td>
<td align="right">71 B</td>
<td align="right">3,241</td>
<td align="right">230 KB</td>
<td align="right">0.13%</td>
</tr>
<tr>
<td>1-of-1</td>
<td>U</td>
<td align="right">69 B</td>
<td align="right">752</td>
<td align="right">52 KB</td>
<td align="right">0.03%</td>
</tr>
<tr>
<td>2-of-3</td>
<td>CCC</td>
<td align="right">105 B</td>
<td align="right">482</td>
<td align="right">51 KB</td>
<td align="right">0.02%</td>
</tr>
<tr>
<td>1-of-2</td>
<td>UU</td>
<td align="right">135 B</td>
<td align="right">146</td>
<td align="right">20 KB</td>
<td align="right">0.01%</td>
</tr>
<tr>
<td>1-of-1</td>
<td>C</td>
<td align="right">37 B</td>
<td align="right">369</td>
<td align="right">14 KB</td>
<td align="right">0.02%</td>
</tr>
<tr>
<td>2-of-3</td>
<td>UUU</td>
<td align="right">201 B</td>
<td align="right">22</td>
<td align="right">4.4 KB</td>
<td align="right">&#x3C;0.01%</td>
</tr>
<tr>
<td>1-of-3</td>
<td>CUU</td>
<td align="right">169 B</td>
<td align="right">16</td>
<td align="right">2.7 KB</td>
<td align="right">&#x3C;0.01%</td>
</tr>
<tr>
<td>3-of-3</td>
<td>CCC</td>
<td align="right">105 B</td>
<td align="right">20</td>
<td align="right">2.1 KB</td>
<td align="right">&#x3C;0.01%</td>
</tr>
<tr>
<td>2-of-2</td>
<td>UU</td>
<td align="right">135 B</td>
<td align="right">11</td>
<td align="right">1.5 KB</td>
<td align="right">&#x3C;0.01%</td>
</tr>
<tr>
<td>2-of-2</td>
<td>CU</td>
<td align="right">103 B</td>
<td align="right">10</td>
<td align="right">1.0 KB</td>
<td align="right">&#x3C;0.01%</td>
</tr>
<tr>
<td>2-of-3</td>
<td>CCU</td>
<td align="right">137 B</td>
<td align="right">5</td>
<td align="right">685 B</td>
<td align="right">&#x3C;0.01%</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td></td>
<td align="right"></td>
<td align="right"><strong>2,423,456</strong></td>
<td align="right"><strong>252.2 MB</strong></td>
<td align="right"><strong>100.00%</strong></td>
</tr>
</tbody>
</table>
<p><strong>Table 11:</strong> P2MS multisig configurations in the UTXO set showing key combinations, script sizes, and total data footprint. C = compressed keys (33 bytes), U = uncompressed keys (65 bytes).</p>
<p>Table 11 reveals that the total data size of all P2MS outputs in the UTXO set is 252.2 MB, with 1-of-3 multisig with compressed keys accounting for 223 MB (87.63%) of this data footprint alone.
Note that the entire UTXO set at block height 918,997 is approximately 11.4 GB in size, meaning P2MS outputs account for ~2.2% of the total UTXO set size, despite only representing 1.46% of the total outputs.</p>
<p>As a point of reference, according to BitMEX Research on <a href="https://www.bitmex.com/blog/ordinals-impact-on-node-runners">Ordinals - Impact on Node Runners</a>, Ordinal images and other data take up around 30GB of blockchain space as of September 2025, with an additional ~27GB used by BRC-20 related transactions.
So the contribution of P2MS outputs to the overall UTXO set size is relatively minor in comparison, though the effectively unspendable nature of much of the P2MS data does raise questions about UTXO set bloat and long-term sustainability.</p>
<h3 id="transaction-size-distribution">Transaction size distribution</h3>
<p>While the previous section examined the size of individual P2MS outputs, it's also informative to consider the size of entire transactions that contain P2MS outputs.
Transaction size directly determines block space consumption and, consequently, the fees paid by users of these data-carrying protocols.</p>
<p>Figure 3 shows the distribution of transaction sizes across the 1.33 million transactions relating to the unspent P2MS outputs.
The overwhelming majority of transactions (1.17M, or 88%) fall within the 250-500 byte range, reflecting the typical size of P2MS transactions used by Bitcoin Stamps and Counterparty.</p>
<p><strong>[Interactive plot - view on website]</strong></p>
<p>Distribution of P2MS transaction sizes, as of block height 918,997 (14 October 2025).</p>
<h3 id="utxo-value-breakdown">UTXO value breakdown</h3>
<h4 id="value-distribution">Value distribution</h4>
<p>Figure 4 shows the distribution of P2MS output values across different ranges, with protocol-specific breakdowns available via the legend.
This figure reveals the following insights:</p>
<ul>
<li><strong>A mode at 546-1K sats</strong>: 1.82M outputs (75% of all P2MS outputs), almost entirely attributable to Bitcoin Stamps.
This is just above the 546 sat dust threshold, obviously motivated by ensuring transaction standardness while minimising the cost of data embedding.</li>
<li><strong>A mode at 5K-10K sats</strong>: a secondary peak of ~402K outputs, dominated by Counterparty transactions.</li>
<li><strong>Sub-dust range (0-546 sats) contains 16,861 outputs</strong>: Data Storage accounting for nearly all of them (16,847).
This is explored in the following.</li>
</ul>
<p><strong>[Interactive plot - view on website]</strong></p>
<p>P2MS UTXO Value Distribution by protocol and value range, as of block height 918,997 (14 October 2025).</p>
<h4 id="dust-threshold-analysis">Dust threshold analysis</h4>
<p>The value of UTXOs is relevant in the context of dust limits, as outputs below the dust threshold are non-standard and would not be relayed by most Bitcoin nodes were they to appear in a transaction.
It might seem that the dust limit for P2MS outputs depends on the multisig configuration and key types used, but this is only true for the creation, and not spending, of P2MS outputs.
The following unpacks how Bitcoin Core calculates the dust threshold for outputs; we'll find that the dust threshold to spend P2MS outputs is 546 sats when spending to a non-segwit output (e.g., P2PKH), or 294 sats when spending to a segwit output (e.g., P2WPKH), <em><strong>regardless of the multisig configuration or key types used</strong></em>.</p>
<p><strong>Bitcoin Core Policy &#x26; Dust Threshold Calculation</strong></p>
<p>Each output is checked whether it is dust via <a href="https://github.com/bitcoin/bitcoin/blob/a14e7b9dee9145920f93eab0254ce92942bd1e5e/src/policy/policy.cpp#L65"><code>IsDust</code></a>, with the output value evaluated against the dust threshold (<a href="https://github.com/bitcoin/bitcoin/blob/a14e7b9dee9145920f93eab0254ce92942bd1e5e/src/policy/policy.cpp#L26"><code>GetDustThreshold</code></a>).
Both of these methods require a value for the <code>dustRelayFeeIn</code> argument; this is <code>DUST_RELAY_TX_FEE</code> which has a current value of 3000 sat/kvB (set <a href="https://github.com/bitcoin/bitcoin/blob/a14e7b9dee9145920f93eab0254ce92942bd1e5e/src/policy/policy.h#L64">here</a>).</p>
<pre><code class="hljs language-c++"><span class="hljs-function">CAmount <span class="hljs-title">GetDustThreshold</span><span class="hljs-params">(<span class="hljs-type">const</span> CTxOut&#x26; txout, <span class="hljs-type">const</span> CFeeRate&#x26; dustRelayFeeIn)</span>
</span>{
    <span class="hljs-comment">// "Dust" is defined in terms of dustRelayFee,</span>
    <span class="hljs-comment">// which has units satoshis-per-kilobyte.</span>
    <span class="hljs-comment">// If you'd pay more in fees than the value of the output</span>
    <span class="hljs-comment">// to spend something, then we consider it dust.</span>
    <span class="hljs-comment">// A typical spendable non-segwit txout is 34 bytes big, and will</span>
    <span class="hljs-comment">// need a CTxIn of at least 148 bytes to spend:</span>
    <span class="hljs-comment">// so dust is a spendable txout less than</span>
    <span class="hljs-comment">// 182*dustRelayFee/1000 (in satoshis).</span>
    <span class="hljs-comment">// 546 satoshis at the default rate of 3000 sat/kvB.</span>
    <span class="hljs-comment">// A typical spendable segwit P2WPKH txout is 31 bytes big, and will</span>
    <span class="hljs-comment">// need a CTxIn of at least 67 bytes to spend:</span>
    <span class="hljs-comment">// so dust is a spendable txout less than</span>
    <span class="hljs-comment">// 98*dustRelayFee/1000 (in satoshis).</span>
    <span class="hljs-comment">// 294 satoshis at the default rate of 3000 sat/kvB.</span>
    <span class="hljs-keyword">if</span> (txout.scriptPubKey.<span class="hljs-built_in">IsUnspendable</span>())
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-type">size_t</span> nSize = <span class="hljs-built_in">GetSerializeSize</span>(txout);
    <span class="hljs-type">int</span> witnessversion = <span class="hljs-number">0</span>;
    std::vector&#x3C;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>> witnessprogram;

    <span class="hljs-comment">// Note this computation is for spending a Segwit v0 P2WPKH output (a 33 bytes</span>
    <span class="hljs-comment">// public key + an ECDSA signature). For Segwit v1 Taproot outputs the minimum</span>
    <span class="hljs-comment">// satisfaction is lower (a single BIP340 signature) but this computation was</span>
    <span class="hljs-comment">// kept to not further reduce the dust level.</span>
    <span class="hljs-comment">// See discussion in https://github.com/bitcoin/bitcoin/pull/22779 for details.</span>
    <span class="hljs-keyword">if</span> (txout.scriptPubKey.<span class="hljs-built_in">IsWitnessProgram</span>(witnessversion, witnessprogram)) {
        <span class="hljs-comment">// sum the sizes of the parts of a transaction input</span>
        <span class="hljs-comment">// with 75% segwit discount applied to the script size.</span>
        nSize += (<span class="hljs-number">32</span> + <span class="hljs-number">4</span> + <span class="hljs-number">1</span> + (<span class="hljs-number">107</span> / WITNESS_SCALE_FACTOR) + <span class="hljs-number">4</span>);
    } <span class="hljs-keyword">else</span> {
        nSize += (<span class="hljs-number">32</span> + <span class="hljs-number">4</span> + <span class="hljs-number">1</span> + <span class="hljs-number">107</span> + <span class="hljs-number">4</span>); <span class="hljs-comment">// the 148 mentioned above</span>
    }

    <span class="hljs-keyword">return</span> dustRelayFeeIn.<span class="hljs-built_in">GetFee</span>(nSize);
}
</code></pre>
<p>As can be observed in the code snippet, <code>GetDustThreshold</code> calculates the serialised size of the output and then adds 148 to it, to establish a size for fee calculation.
As the comment suggests, this 148 bytes is an assumption of the size of the <code>scriptSig</code> needed to spend the output and represents the spending of a typical P2PKH input:</p>
<ul>
<li>32 bytes: <code>txid</code> (references the previous output's transaction)</li>
<li>4 bytes: <code>vout</code> (index of the output within that transaction)</li>
<li>1 byte: <code>scriptSig</code> length</li>
<li>107 bytes: typical <code>scriptSig</code> size, e.g. <code>OP_PUSHBYTES_72</code> <code>&#x3C;72-byte-sig></code> <code>OP_PUSHBYTES_33</code> <code>&#x3C;33-byte-compressed-key></code></li>
<li>4 bytes: <code>sequence</code></li>
</ul>
<p>Although this fixed input size is used for all non-segwit inputs, it's worth considering what the input size would look like to spend a P2MS output.
We'd have the common elements of <code>txid</code> (32 bytes), <code>vout</code> (4 bytes), <code>scriptSig</code> length (1 byte), and <code>sequence</code> (4 bytes), for 41 bytes.
The <code>scriptSig</code> is where we'd see variation depending on the number of required signatures (m) in the m-of-n multisig configuration.
Note that there is an <code>OP_0</code> dummy element to address the extra stack element consumed by <code>OP_CHECKMULTISIG</code> and <code>OP_CHECKMULTISIGVERIFY</code>, as per <a href="https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki">BIP-147</a>, and we assume the mid-point 72-bytes for a signature.</p>
<table>
<thead>
<tr>
<th>Multisig configuration</th>
<th><code>scriptSig</code> breakdown</th>
<th align="right"><code>scriptSig</code> size (bytes)</th>
<th align="right">Total size (bytes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-of-n</td>
<td>1 (<code>OP_0</code>) + 1 (<code>OP_PUSHBYTES_72</code>) + 72 (<code>&#x3C;signature></code>)</td>
<td align="right">74</td>
<td align="right">115</td>
</tr>
<tr>
<td>2-of-n</td>
<td>1 (<code>OP_0</code>) + 2 * (1 (<code>OP_PUSHBYTES_72</code>) + 72 (<code>&#x3C;signature></code>))</td>
<td align="right">147</td>
<td align="right">188</td>
</tr>
<tr>
<td>3-of-n</td>
<td>1 (<code>OP_0</code>) + 3 * (1 (<code>OP_PUSHBYTES_72</code>) + 72 (<code>&#x3C;signature></code>))</td>
<td align="right">220</td>
<td align="right">261</td>
</tr>
</tbody>
</table>
<p>As for a serialised P2MS output, we would have something like the following in the typical case (involving compressed public keys):</p>
<ul>
<li>8 bytes: <code>amount</code></li>
<li>1 byte: <code>scriptPubKey</code> length</li>
<li>1 byte: <code>OP_m</code>, for the m in m-of-n</li>
<li>34 * n bytes: n * (1 (<code>OP_PUSHBYTES_33</code>) + 33 (<code>&#x3C;33-byte-compressed-key></code>))</li>
<li>1 byte: <code>OP_n</code>, for the n in m-of-n</li>
<li>1 byte: <code>OP_CHECKMULTISIG</code></li>
</ul>
<p>Because the dust threshold is calculated based on the total size of the output plus an assumed fixed size of 148 bytes for the input, the dust threshold only depends on n, the number of keys in the multisig configuration, and NOT on m, the number of required signatures.</p>
<table>
<thead>
<tr>
<th>Multisig configuration</th>
<th align="right">Output size (vbytes)</th>
<th align="right"><code>nSize</code> (vbytes)</th>
<th align="right">Dust Threshold (sats)</th>
</tr>
</thead>
<tbody>
<tr>
<td>m-of-1</td>
<td align="right">46</td>
<td align="right">194</td>
<td align="right">582</td>
</tr>
<tr>
<td>m-of-2</td>
<td align="right">80</td>
<td align="right">228</td>
<td align="right">684</td>
</tr>
<tr>
<td>m-of-3</td>
<td align="right">114</td>
<td align="right">262</td>
<td align="right">786</td>
</tr>
</tbody>
</table>
<p>When spending P2MS UTXOs, the minimum output value <strong>is determined by the destination output type</strong>—546 sats for P2PKH or 294 sats for P2WPKH—regardless of the P2MS configuration being spent.
This is because the dust threshold calculation uses the fixed 148-byte input size assumption.
For example, spending a P2MS UTXO to create a P2PKH output requires the P2MS UTXO to have sufficient value to cover the 546 sat minimum plus transaction fees.</p>
<p>Having established the theoretical dust thresholds, we can now examine how many P2MS outputs actually fall below these thresholds. Table 12 shows the breakdown by protocol.</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th align="right">Total</th>
<th align="right">&#x3C;294 sats</th>
<th align="right">&#x3C;546 sats</th>
<th align="right">≥546 sats</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitcoin Stamps</td>
<td align="right">1,782,916</td>
<td align="right">0 (0%)</td>
<td align="right">0 (0%)</td>
<td align="right">1,782,916 (100%)</td>
</tr>
<tr>
<td>Counterparty</td>
<td align="right">553,981</td>
<td align="right">0 (0%)</td>
<td align="right">0 (0%)</td>
<td align="right">553,981 (100%)</td>
</tr>
<tr>
<td>Omni Layer</td>
<td align="right">43,077</td>
<td align="right">3 (0%)</td>
<td align="right">3 (0%)</td>
<td align="right">43,074 (100%)</td>
</tr>
<tr>
<td>Data Storage</td>
<td align="right">28,831</td>
<td align="right">16,847 (58%)</td>
<td align="right">16,847 (58%)</td>
<td align="right">11,984 (42%)</td>
</tr>
<tr>
<td>Chancecoin</td>
<td align="right">5,051</td>
<td align="right">0 (0%)</td>
<td align="right">0 (0%)</td>
<td align="right">5,051 (100%)</td>
</tr>
<tr>
<td>PPk</td>
<td align="right">4,728</td>
<td align="right">0 (0%)</td>
<td align="right">0 (0%)</td>
<td align="right">4,728 (100%)</td>
</tr>
<tr>
<td>Likely Data Storage</td>
<td align="right">2,152</td>
<td align="right">10 (&#x3C;1%)</td>
<td align="right">10 (&#x3C;1%)</td>
<td align="right">2,142 (99%)</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td align="right">1,352</td>
<td align="right">1 (0%)</td>
<td align="right">1 (0%)</td>
<td align="right">1,351 (100%)</td>
</tr>
<tr>
<td>ASCII Identifier Protocols</td>
<td align="right">816</td>
<td align="right">0 (0%)</td>
<td align="right">0 (0%)</td>
<td align="right">816 (100%)</td>
</tr>
<tr>
<td>Likely Legitimate Multisig</td>
<td align="right">552</td>
<td align="right">0 (0%)</td>
<td align="right">0 (0%)</td>
<td align="right">552 (100%)</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>2,423,456</strong></td>
<td align="right"><strong>16,861 (0.7%)</strong></td>
<td align="right"><strong>16,861 (0.7%)</strong></td>
<td align="right"><strong>2,406,595 (99.3%)</strong></td>
</tr>
</tbody>
</table>
<p><strong>Table 12:</strong> Dust threshold analysis of P2MS UTXOs as of block height 918,997 (14 October 2025).</p>
<p>The results reveal that 99.3% of P2MS outputs are at or above the 546 sat threshold, meaning they are not considered dust for spending purposes.
Only 16,861 outputs (0.7%) fall below the dust threshold, and notably all of these are below 294 sats (dust for all destination types).</p>
<p>The Data Storage category is the clear outlier, with 58% of its outputs (16,847) below the dust threshold.
These sub-dust outputs largely correspond to the data embedding efforts of 2013.</p>
<h3 id="fee-breakdown">Fee breakdown</h3>
<p>Beyond the value locked in P2MS outputs, users have paid substantial transaction fees to embed data using this script type. Table 13 shows the total fees paid by each protocol classification, for all transactions creating unspent P2MS outputs.</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th align="right">Fees (BTC)</th>
<th align="right">% of Total</th>
<th align="right">Avg Fee/TX (sats)</th>
<th align="right">Avg Fee/Byte (sat/byte)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitcoin Stamps</td>
<td align="right">218.50505161</td>
<td align="right">77.67%</td>
<td align="right">22,529</td>
<td align="right">61.06</td>
</tr>
<tr>
<td>Counterparty</td>
<td align="right">47.58227325</td>
<td align="right">16.91%</td>
<td align="right">15,669</td>
<td align="right">32.64</td>
</tr>
<tr>
<td>Omni Layer</td>
<td align="right">8.87842992</td>
<td align="right">3.16%</td>
<td align="right">21,884</td>
<td align="right">48.74</td>
</tr>
<tr>
<td>Data Storage</td>
<td align="right">5.54695739</td>
<td align="right">1.97%</td>
<td align="right">105,195</td>
<td align="right">29.17</td>
</tr>
<tr>
<td>Likely Data Storage</td>
<td align="right">0.22754496</td>
<td align="right">0.08%</td>
<td align="right">18,837</td>
<td align="right">23.80</td>
</tr>
<tr>
<td>ASCII Identifier Protocols</td>
<td align="right">0.14692917</td>
<td align="right">0.05%</td>
<td align="right">21,703</td>
<td align="right">51.78</td>
</tr>
<tr>
<td>Likely Legitimate Multisig</td>
<td align="right">0.14583943</td>
<td align="right">0.05%</td>
<td align="right">27,832</td>
<td align="right">80.91</td>
</tr>
<tr>
<td>Chancecoin</td>
<td align="right">0.11400933</td>
<td align="right">0.04%</td>
<td align="right">4,307</td>
<td align="right">10.36</td>
</tr>
<tr>
<td>OP_RETURN Signalled</td>
<td align="right">0.08389254</td>
<td align="right">0.03%</td>
<td align="right">6,251</td>
<td align="right">15.54</td>
</tr>
<tr>
<td>PPk</td>
<td align="right">0.06092428</td>
<td align="right">0.02%</td>
<td align="right">1,295</td>
<td align="right">3.75</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>281.29185188</strong></td>
<td align="right"><strong>100%</strong></td>
<td align="right"><strong>21,143</strong></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p><strong>Table 13:</strong> Fee breakdown of P2MS UTXOs by protocol classification as of block height 918,997 (14 October 2025).</p>
<p>Bitcoin Stamps dominates fee expenditure at 218.5 BTC (77.7% of all P2MS-related fees), reflecting both its transaction volume and its emergence during higher fee environments in 2023.
Figure 5 shows the weekly distribution of Bitcoin Stamps fees since the protocol's launch.</p>
<blockquote>
<p><strong>Over 281 BTC has been spent on transaction fees to embed data in P2MS outputs, with Bitcoin Stamps accounting for ~78%.</strong></p>
</blockquote>
<p>The Data Storage category shows the highest average fee per transaction at 105,195 sats due to the larger transaction sizes required for bulk data embedding (e.g., "WikiLeaks Cablegate" files, "Bitcoin Whitepaper").
Conversely, PPk transactions paid the lowest fees at just 1,295 sats average, a result of both the protocol's age (operating during lower fee periods) and its small payload sizes.</p>
<h2 id="p2ms-utxos-by-protocoluse">P2MS UTXOs by protocol/use</h2>
<p>The following sections provide deeper analysis of the major protocols, including covering the various sub-protocols or variants where applicable.
If you don't care for the details, e.g., of the various Counterparty or Omni message types, I recommend just reading the Bitcoin Stamps section immediately following, and then skip ahead to the <a href="#what-to-make-of-all-this">summary section - "What to make of all this?"</a>.</p>
<h3 id="bitcoin-stamps">Bitcoin Stamps</h3>
<p>As briefly covered in <a href="./p2ms-data-carry-1#bitcoin-stamps-sub-protocols">Part 1</a>, the primary indicator of a Bitcoin Stamp is the presence of designated "Key Burn" in the third pubkey position of a 1-of-3 multisig.
In the classification system, after Key Burn detection, data is extracted from the first two pubkeys and ARC4-decrypted using the first input's txid as the key.
The decrypted payload must contain a <code>stamp:</code> (or variant) signature to confirm validity.</p>
<p>Variant classification then proceeds in priority order: compressed data (ZLIB/GZIP) is identified first, followed by image formats (PNG, GIF, JPEG, WebP, SVG, BMP, PDF) which constitute the "Classic" variant.
JSON payloads are parsed for protocol markers such as <code>"p":"src-20"</code> ("SRC-20" - fungible tokens), <code>"p":"src-721"</code> ("SRC-721" - non-fungible tokens) and <code>"p":"src-101"</code> ("SRC-101" - naming service). HTML documents and generic binary data fall into subsequent categories.</p>
<p>The system also distinguishes between "Pure" Bitcoin Stamps (direct P2MS encoding) and those embedded within Counterparty transport, which exhibit both <code>CNTRPRTY</code> and <code>stamp:</code> signatures in the decrypted payload.</p>
<p>Table 14 shows the composition of P2MS outputs associated with Bitcoin Stamps in the UTXO set.</p>
<table>
<thead>
<tr>
<th>Variant</th>
<th align="right">Transactions</th>
<th align="right">P2MS outputs</th>
<th align="right">Avg outputs/TX</th>
<th align="right">% of total outputs</th>
</tr>
</thead>
<tbody>
<tr>
<td>SRC-20</td>
<td align="right">933,026</td>
<td align="right">1,604,238</td>
<td align="right">1.72</td>
<td align="right">89.98%</td>
</tr>
<tr>
<td>SRC-721</td>
<td align="right">29,289</td>
<td align="right">88,550</td>
<td align="right">3.02</td>
<td align="right">4.97%</td>
</tr>
<tr>
<td>Classic (images)</td>
<td align="right">4,181</td>
<td align="right">72,243</td>
<td align="right">17.28</td>
<td align="right">4.05%</td>
</tr>
<tr>
<td>SRC-101</td>
<td align="right">2,135</td>
<td align="right">13,767</td>
<td align="right">6.45</td>
<td align="right">0.77%</td>
</tr>
<tr>
<td>Compressed</td>
<td align="right">1,059</td>
<td align="right">2,134</td>
<td align="right">2.02</td>
<td align="right">0.12%</td>
</tr>
<tr>
<td>HTML</td>
<td align="right">25</td>
<td align="right">1,035</td>
<td align="right">41.40</td>
<td align="right">0.06%</td>
</tr>
<tr>
<td>Data</td>
<td align="right">82</td>
<td align="right">820</td>
<td align="right">10.00</td>
<td align="right">0.05%</td>
</tr>
<tr>
<td>Unknown</td>
<td align="right">71</td>
<td align="right">129</td>
<td align="right">1.82</td>
<td align="right">0.01%</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>969,868</strong></td>
<td align="right"><strong>1,782,916</strong></td>
<td align="right"><strong>1.84</strong></td>
<td align="right"><strong>100.00%</strong></td>
</tr>
</tbody>
</table>
<p><strong>Table 14:</strong> Bitcoin Stamps sub-protocol composition as of block height 918,997 (14 October 2025).</p>
<p>"SRC-20" tokens dominate at ~90% of Bitcoin Stamps P2MS outputs, reflecting the protocol's primary use for "fungible token operations". "SRC-20" is a JSON-only protocol, so all "SRC-20" P2MS outputs contain JSON data like the following (as decoded in <a href="./p2ms-data-carry-1#data-carrying-in-p2ms-a-bitcoin-stamps-example">Part 1</a>):</p>
<pre><code class="hljs language-json">stamp<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
	<span class="hljs-attr">"p"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"src-20"</span><span class="hljs-punctuation">,</span>
	<span class="hljs-attr">"op"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"transfer"</span><span class="hljs-punctuation">,</span>
	<span class="hljs-attr">"tick"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"BMWK"</span><span class="hljs-punctuation">,</span>
	<span class="hljs-attr">"amt"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"1000"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>"SRC-721", accounting for ~5% of Bitcoin Stamps P2MS outputs, is also JSON-only, as is "SRC-101" (~0.8% of outputs).
With "SRC-20", "SRC-721", and "SRC-101" all being JSON-based, the vast majority of Bitcoin Stamps P2MS outputs contain JSON data, explaining why <code>application/json</code> dominates the overall content type distribution at 72.64% (as covered in the <a href="#data-content-type-breakdown">content type breakdown</a>).</p>
<p>"Classic Stamps", the original Bitcoin Stamps protocol that encodes images directly into P2MS outputs, accounts for ~4% of Bitcoin Stamps P2MS outputs.
Approximately 4,200 images, predominantly PNGs and GIFs have been embedded using "Classic Stamps", though there are many more images stored on-chain by Bitcoin Stamps using other techniques and script types such as OLGA and P2TR.</p>
<p><strong>"Classic Stamps"</strong>:</p>
<ul>
<li>PNG images: 3,342 (80%)</li>
<li>GIF animations: 603 (14%)</li>
<li>SVG graphics: 130 (3%)</li>
<li>JPEG images: 60 (1%)</li>
<li>Other formats: 44 (1%)</li>
</ul>
<p>Bitcoin Stamps utilises two distinct transport mechanisms, as summarised in Table 15.
Counterparty was the original transport layer for Bitcoin Stamps, but given the significant overhead, a native Bitcoin Stamps transport mechanism was later developed and introduced.
The overheads of Counterparty were explored in <a href="./p2ms-data-carry-1#summarising-the-main-techniques">Part 1</a>.</p>
<table>
<thead>
<tr>
<th>Transport Method</th>
<th align="right">Transactions</th>
<th align="right">Percentage</th>
</tr>
</thead>
<tbody>
<tr>
<td>Counterparty</td>
<td align="right">78,263</td>
<td align="right">8.1%</td>
</tr>
<tr>
<td>"Pure" Bitcoin Stamps</td>
<td align="right">891,605</td>
<td align="right">91.9%</td>
</tr>
</tbody>
</table>
<p><strong>Table 15:</strong> Bitcoin Stamps transport mechanism breakdown.</p>
<p>Despite the relatively low value locked in outputs (14.19 BTC), Bitcoin Stamps users have demonstrated their willingness to pay for the "permanence guarantee".
For example, with the protocol having emerged during the 2023 Ordinals/Inscriptions hype, the fact that
people chose to use Bitcoin Stamps over Ordinals/Inscriptions can perhaps be seen as a preference for permanence over lower cost.</p>
<p>Although the average value per Bitcoin Stamps P2MS output is just 796 sats (Table 16), with the average size of a Classic Stamp being 17.28 outputs per transaction (Table 14), the average cost per Classic Stamp transaction is ~13,760 sats just for the outputs alone, plus transaction fees.
On the matter of fees, Bitcoin Stamps users have paid approximately 218.50 BTC in transaction fees to embed data using P2MS outputs since the protocol's inception.</p>
<table>
<thead>
<tr>
<th>Metric</th>
<th align="right">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Total BTC in P2MS outputs</td>
<td align="right">~14.19 BTC</td>
</tr>
<tr>
<td>Average value per output</td>
<td align="right">796 sats</td>
</tr>
<tr>
<td>Minimum value</td>
<td align="right">546 sats (dust limit)</td>
</tr>
<tr>
<td>Maximum value</td>
<td align="right">7,800 sats</td>
</tr>
<tr>
<td>Total fees paid</td>
<td align="right">~218.50 BTC</td>
</tr>
</tbody>
</table>
<p><strong>Table 16:</strong> Economic metrics for Bitcoin Stamps P2MS outputs.</p>
<p><strong>[Interactive plot - view on website]</strong></p>
<p>Bitcoin Stamps weekly fee expenditure from protocol inception (April 2023) through October 2025. The average sats/vbyte trace (green) is available via the legend.</p>
<p>Figure 5 shows the weekly distribution of these fees over time.
The chart displays total weekly fees (bars) alongside average fee per transaction (blue line) on a secondary axis.</p>
<p>This data reveals:</p>
<ul>
<li><strong>Peak activity in late 2023</strong>: Weekly fees peaked at over 51 BTC during the week of 14 December 2023, coinciding with broader network congestion and high demand for block space (see figure).
During this period, average fees per transaction reached approximately 167,500 sats (~US$70 at the time!).</li>
<li><strong>Majority of fees paid over a handful of weeks</strong>: ~66% of all Bitcoin Stamps fees were paid during just 10 weeks between November 2023 and February 2024, so simply considering the total fees paid can be misleading without temporal context.</li>
</ul>
<p><img src="https://deadmanoz.xyz/assets/blog/p2ms-data-carry/mempool-graph-3y-1764302242.svg" alt="Figure: Bitcoin mempool size (in MvB) from November 2022 to November 2025, showing periods of elevated congestion. From mempool.space"></p>
<p>The "Stamp" in Bitcoin Stamps is (presumably) a backronym: Secure Tradeable Artifacts Maintained Permanently.
And the original motivation was <a href="https://github.com/mikeinspace/stamps/blob/main/BitcoinStamps.md"><em>"Storing 'Art on the Blockchain' as a method of achieving permanence"</em></a>.
Yet we've seen that the dominant use case for Bitcoin Stamps is fungible token operations ("SRC-20"), which arguably diverges from the original intent of "art".</p>
<p>Figure 6 explores how the distribution of Bitcoin Stamps variants (those utilising P2MS) has evolved over time.
It's clear that the "art" use case ("Classic Stamps") has not been seen since March 2024, with only "SRC-20" and "SRC-101" seeing use in 2025.
This is important context if one were to consider if the continued use of P2MS outputs by Bitcoin Stamps is justified, especially given their deliberately unspendable design.
This is discussed further in the <a href="#what-to-make-of-all-this">summary section</a>.</p>
<p><strong>[Interactive plot - view on website]</strong></p>
<p>Weekly distribution of Bitcoin Stamps variants by output count.</p>
<h3 id="counterparty">Counterparty</h3>
<p>Counterparty is the second largest contributor to P2MS outputs in the UTXO set, accounting for ~23% of all such outputs.
Unlike Bitcoin Stamps' deliberately unspendable outputs, every Counterparty P2MS output contains, in theory, at least one valid public key, ensuring spendability and avoiding permanent UTXO set inclusion.
~35.86 BTC is currently locked in Counterparty P2MS outputs.</p>
<p>The 8-byte <code>CNTRPRTY</code> prefix identifies Counterparty messages after successful ARC4 decryption (again, the full process has been explored in <a href="./p2ms-data-carry-1#counterparty">Part 1</a>).
Although there are 20+ different Counterparty protocol message types, they have been consolidated into 7 semantically meaningful high-level variants for the purposes of analysis:</p>
<ol>
<li><strong>Counterparty Issuance</strong> - Issuance, Fair Minter, Fair Mint</li>
<li><strong>Counterparty Transfer</strong> - Send, Enhanced Send, Multi-Party, Multi-Asset (MPMA), Sweep, Dividend</li>
<li><strong>Counterparty DEX</strong> - Decentralised Exchange: Order, BTC Pay, Dispenser, Cancel</li>
<li><strong>Counterparty Oracle</strong> - Broadcast</li>
<li><strong>Counterparty Gaming</strong> - Bet, Rock-Paper-Scissors (RPS), RPS Resolve</li>
<li><strong>Counterparty Utility</strong> - UTXO, Attach, Detach</li>
<li><strong>Counterparty Destruction</strong> - Asset destruction: Destroy, Burn</li>
</ol>
<table>
<thead>
<tr>
<th>Variant</th>
<th align="right">Transactions</th>
<th align="right">P2MS Outputs</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Counterparty Transfer</td>
<td align="right">188,423</td>
<td align="right">195,174</td>
<td>Token transfers between addresses</td>
</tr>
<tr>
<td>Counterparty Issuance</td>
<td align="right">72,835</td>
<td align="right">283,160</td>
<td>Creating new tokens/assets</td>
</tr>
<tr>
<td>Counterparty DEX</td>
<td align="right">33,298</td>
<td align="right">52,542</td>
<td>Decentralised exchange operations</td>
</tr>
<tr>
<td>Counterparty Oracle</td>
<td align="right">7,811</td>
<td align="right">20,293</td>
<td>Price feeds and data broadcasts</td>
</tr>
<tr>
<td>Counterparty Gaming</td>
<td align="right">1,242</td>
<td align="right">2,519</td>
<td>Betting and game-related operations</td>
</tr>
<tr>
<td>Counterparty Utility</td>
<td align="right">60</td>
<td align="right">263</td>
<td>UTXO management (attach/detach)</td>
</tr>
<tr>
<td>Counterparty Destruction</td>
<td align="right">8</td>
<td align="right">30</td>
<td>Burning/destroying tokens</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>303,677</strong></td>
<td align="right"><strong>553,981</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Table 17:</strong> Breakdown of Counterparty variants observed in P2MS UTXOs, as of block height 918,997 (14 October 2025).</p>
<p>Counterparty uses two primary multisig configurations:</p>
<ul>
<li>1-of-3: 72.10% of outputs</li>
<li>1-of-2: 27.79% of outputs</li>
</ul>
<p>The remaining configurations (2-of-2, 2-of-3, 3-of-3) account for 0.11% of all Counterparty P2MS UTXOs.</p>
<h3 id="omni">Omni</h3>
<p>Omni is a distant third in terms of P2MS UTXO contribution, accounting for ~1.8% of all such outputs.
Similar to Counterparty, every Omni P2MS output contains at least one valid public key, ensuring spendability and avoiding permanent UTXO set inclusion.
All 43,077 Omni P2MS outputs are spendable and ~2.32 BTC is currently locked in Omni P2MS outputs.</p>
<p>Omni transactions are identified by the presence of the Exodus address (<a href="https://mempool.space/address/1EXoDusjGwvnjZUyKkxZ4UHEf77z6A5S4P"><code>1EXoDusj...</code></a>) as a transaction output.
Once the Exodus address is confirmed, the Omni payload is extracted from the P2MS outputs using the process described in <a href="./p2ms-data-carry-1#omni-formerly-mastercoin">Part 1</a>.
If deobfuscation is not successful, the transaction and P2MS outputs are marked as "Omni Failed Deobfuscation", otherwise the message type is parsed and classified accordingly.</p>
<p>Like Counterparty, Omni has 20+ message types, which can be consolidated into a smaller number of high-level variants for analysis:</p>
<ol>
<li><strong>Omni Transfer</strong> - SimpleSend, RestrictedSend, SendAll, SendNonFungible (types 0, 2, 4, 5)</li>
<li><strong>Omni Issuance</strong> - CreatePropertyFixed, CreatePropertyVariable, PromoteProperty, CreatePropertyManual, GrantPropertyTokens (types 50, 51, 52, 54, 55)</li>
<li><strong>Omni DEX</strong> - TradeOffer, AcceptOfferBTC, MetaDEXTrade, MetaDEXCancelPrice, MetaDEXCancelPair, MetaDEXCancelEcosystem (types 20, 22, 25-28)</li>
<li><strong>Omni Failed Deobfuscation</strong> - Exodus address present but deobfuscation failed</li>
<li><strong>Omni Destruction</strong> - RevokePropertyTokens (type 56)</li>
<li><strong>Omni Administration</strong> - CloseCrowdsale, ChangeIssuerAddress, EnableFreezing, DisableFreezing, FreezePropertyTokens, UnfreezePropertyTokens (types 53, 70, 71, 72, 185, 186)</li>
<li><strong>Omni Distribution</strong> - SendToOwners (type 3)</li>
</ol>
<table>
<thead>
<tr>
<th>Variant</th>
<th align="right">Transactions</th>
<th align="right">Outputs</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Omni Transfer</td>
<td align="right">37,421</td>
<td align="right">37,432</td>
<td>Token transfers between addresses</td>
</tr>
<tr>
<td>Omni Issuance</td>
<td align="right">1,198</td>
<td align="right">3,689</td>
<td>Creating new tokens/assets</td>
</tr>
<tr>
<td>Omni DEX</td>
<td align="right">1,857</td>
<td align="right">1,857</td>
<td>Decentralised exchange operations</td>
</tr>
<tr>
<td>Omni Failed Deobfuscation</td>
<td align="right">52</td>
<td align="right">56</td>
<td>Transactions that couldn't be decoded</td>
</tr>
<tr>
<td>Omni Destruction</td>
<td align="right">24</td>
<td align="right">24</td>
<td>Burning/destroying tokens</td>
</tr>
<tr>
<td>Omni Administration</td>
<td align="right">17</td>
<td align="right">17</td>
<td>Token management operations</td>
</tr>
<tr>
<td>Omni Distribution</td>
<td align="right">2</td>
<td align="right">2</td>
<td>Dividend/airdrop distributions</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>40,571</strong></td>
<td align="right"><strong>43,077</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Table 18:</strong> Breakdown of Omni variants observed in P2MS UTXOs, as of block height 918,997 (14 October 2025).</p>
<p>Omni primarily uses the 1-of-2 multisig configuration, accounting for 90.16% of outputs, with the remaining 9.83% using 1-of-3 (though there are 2 Omni UTXOs that use the odd 1-of-1 configuration).</p>
<h3 id="chancecoin">Chancecoin</h3>
<p>Chancecoin was a gambling-focused protocol that operated on Bitcoin from 2014-2015, using P2MS outputs for its message encoding.
Like Counterparty and Omni, Chancecoin maintains at least one valid public key per output, ensuring spendability.
~0.15 BTC remains locked in Chancecoin P2MS outputs, all of which appears spendable.</p>
<p>Chancecoin message types can be consolidated into the following variants:</p>
<ol>
<li><strong>Chancecoin Roll</strong> - Dice roll results (ID 14)</li>
<li><strong>Chancecoin Bet</strong> - Gambling bets (ID 40/41)</li>
<li><strong>Chancecoin Send</strong> - Token transfers (ID 0)</li>
<li><strong>Chancecoin Order</strong> - DEX order placement (ID 10)</li>
<li><strong>Chancecoin Cancel</strong> - Order cancellation (ID 70)</li>
<li><strong>Chancecoin BTCPay</strong> - BTC payment for DEX trades (ID 11)</li>
</ol>
<table>
<thead>
<tr>
<th>Variant</th>
<th align="right">Transactions</th>
<th align="right">Outputs</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chancecoin Roll</td>
<td align="right">1,912</td>
<td align="right">3,824</td>
<td>Dice roll results</td>
</tr>
<tr>
<td>Chancecoin Bet</td>
<td align="right">368</td>
<td align="right">736</td>
<td>Gambling bets placed</td>
</tr>
<tr>
<td>Chancecoin Send</td>
<td align="right">252</td>
<td align="right">252</td>
<td>Token transfers between addresses</td>
</tr>
<tr>
<td>Chancecoin Order</td>
<td align="right">65</td>
<td align="right">130</td>
<td>DEX order placement</td>
</tr>
<tr>
<td>Chancecoin Cancel</td>
<td align="right">41</td>
<td align="right">82</td>
<td>Order cancellation</td>
</tr>
<tr>
<td>Chancecoin BTCPay</td>
<td align="right">9</td>
<td align="right">27</td>
<td>BTC payment for DEX trades</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>2,647</strong></td>
<td align="right"><strong>5,051</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Table 19:</strong> Breakdown of Chancecoin variants observed in P2MS UTXOs, as of block height 918,997 (14 October 2025).</p>
<p>Chancecoin exclusively uses the 1-of-2 multisig configuration (100% of outputs).</p>
<h3 id="ppk">PPk</h3>
<p>PPk was a decentralised identity and naming protocol that operated on Bitcoin, using P2MS and <code>OP_RETURN</code> outputs for message encoding.
PPk aimed to provide a decentralised alternative to DNS and digital identity systems.</p>
<p>PPk transactions are identified by a distinctive marker pubkey (<code>0320a0de...3e12</code>) that must appear in the second position of a P2MS output.
Once detected, variant classification examines the combined P2MS and <code>OP_RETURN</code> data:</p>
<ul>
<li><strong>PPk Profile</strong>: transactions carry JSON payloads using a "RT" (Resource Tag) and a type–length–value (TLV) structure</li>
<li><strong>PPk Registration</strong>: transactions contain quoted numeric strings like "315"</li>
<li><strong>PPk Message</strong>: transactions contain promotional text with "PPk" substrings or ≥80% printable ASCII</li>
<li><strong>PPk Unknown</strong>: Unrecognised PPk message types that don't fit the above patterns.</li>
</ul>
<table>
<thead>
<tr>
<th>Variant</th>
<th align="right">Transactions</th>
<th align="right">Outputs</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>PPk Message</td>
<td align="right">2,031</td>
<td align="right">2,051</td>
<td>General protocol messages</td>
</tr>
<tr>
<td>PPk Profile</td>
<td align="right">2,003</td>
<td align="right">2,003</td>
<td>Identity/profile data storage</td>
</tr>
<tr>
<td>PPk Unknown</td>
<td align="right">478</td>
<td align="right">480</td>
<td>Unrecognised PPk message types</td>
</tr>
<tr>
<td>PPk Registration</td>
<td align="right">194</td>
<td align="right">194</td>
<td>Name/identity registration</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>4,706</strong></td>
<td align="right"><strong>4,728</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Table 20:</strong> Breakdown of PPk variants observed in P2MS UTXOs, as of block height 918,997 (14 October 2025).</p>
<p>PPk uses two multisig configurations:</p>
<ul>
<li>1-of-3: 70.43% of outputs</li>
<li>1-of-2: 29.57% of outputs</li>
</ul>
<p>All 4,728 PPk P2MS outputs appear spendable and only a small amount of value, ~0.05 BTC, is locked in them.</p>
<h3 id="op_return-signalled">OP_RETURN Signalled</h3>
<p>The OP_RETURN Signalled classification captures transactions where an <code>OP_RETURN</code> output contains a protocol identifier, but the transaction also includes P2MS outputs.
Often the <code>OP_RETURN</code> serves as a protocol identifier, with P2MS outputs providing additional data capacity for the protocol's payload.</p>
<table>
<thead>
<tr>
<th>Variant</th>
<th align="right">Transactions</th>
<th align="right">Outputs</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Protocol47930</td>
<td align="right">742</td>
<td align="right">742</td>
<td>Unknown protocol with identifier <code>47930</code></td>
</tr>
<tr>
<td>Generic ASCII</td>
<td align="right">362</td>
<td align="right">372</td>
<td>ASCII text identifiers without known protocol mapping</td>
</tr>
<tr>
<td><code>CLIPPERZ</code></td>
<td align="right">238</td>
<td align="right">238</td>
<td>Clipperz password manager backup protocol</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>1,342</strong></td>
<td align="right"><strong>1,352</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Table 21:</strong> Breakdown of OP_RETURN Signalled variants observed in P2MS UTXOs, as of block height 918,997 (14 October 2025).</p>
<p>The largest category is "Protocol47930" (54.9%), representing transactions featuring the <code>0xbb3a</code> marker (47930 in decimal).
"Generic ASCII" (27.5%) captures various ASCII-based identifiers that don't match known protocols, examples include <code>CC</code> (138 outputs), <code>8EC=</code> (104 outputs) and <code>DEVCHA</code> (30 outputs).
"CLIPPERZ" (17.6%) corresponds to the <a href="https://clipperz.is/">Clipperz</a> open-source password manager, which at some point in the past seems to have used Bitcoin as a backup storage feature.</p>
<p>Unlike dedicated data-carrying protocols, OP_RETURN Signalled transactions show an odd mix of multisig configurations:</p>
<ul>
<li>2-of-2: 84.1% of outputs</li>
<li>1-of-2: 10.8% of outputs</li>
<li>1-of-3: 4.6% of outputs</li>
</ul>
<p>The prevalence of 2-of-2 configurations (rather than the 1-of-n patterns typical of data-carrying protocols) is notable, since these require multiple valid signatures to spend.
Analysis of EC-point validity shows that 92.53% of these OP_RETURN Signalled P2MS outputs are actually spendable, with ~0.11 BTC currently locked across all OP_RETURN Signalled P2MS outputs.</p>
<h3 id="ascii-identifier-protocols">ASCII Identifier Protocols</h3>
<p>The ASCII Identifier Protocols classification captures P2MS transactions where the embedded data begins with a recognisable ASCII string identifier.
That is, the ASCII string identifier is in the P2MS data (as opposed to OP_RETURN Signalled where the identifier is in the <code>OP_RETURN</code> output).
These represent various experimental or short-lived protocols that used P2MS for data storage.</p>
<table>
<thead>
<tr>
<th>Variant</th>
<th align="right">Transactions</th>
<th align="right">P2MS Outputs</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TB0001</code></td>
<td align="right">323</td>
<td align="right">342</td>
<td>Unknown protocol with <code>TB0001</code> identifier</td>
</tr>
<tr>
<td><code>METROXMN</code></td>
<td align="right">158</td>
<td align="right">181</td>
<td>Associated with Metronotes XMN</td>
</tr>
<tr>
<td><code>TEST01</code></td>
<td align="right">175</td>
<td align="right">179</td>
<td>Transactions with <code>TEST01</code> marker</td>
</tr>
<tr>
<td>Other ASCII Protocol</td>
<td align="right">21</td>
<td align="right">114</td>
<td>Various other ASCII-prefixed data</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>677</strong></td>
<td align="right"><strong>816</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Table 22:</strong> Breakdown of ASCII identifier protocol variants observed in P2MS UTXOs, as of block height 918,997 (14 October 2025).</p>
<p><code>TB0001</code> (41.9%) is the most common variant, though the protocol's purpose remains unidentified. <code>METROXMN</code> (22.2%) is associated with <a href="https://bitcointalk.org/index.php?topic=974486.0">Metronotes XMN</a>, which appears to be a scam. <code>TEST01</code> (21.9%) likely represents testing activity during protocol development or experimentation.
The "Other ASCII Protocol" category (14.0%) is almost entirely <code>NEWBCOIN</code> (113 of 114 outputs), an unknown protocol from late 2014.
Approximately half of the <code>NEWBCOIN</code> transactions (11 of 20) embed gzip-compressed data across multiple P2MS outputs per transaction (9–10 outputs each), while the remainder are single-output transactions without compression.
The single non-<code>NEWBCOIN</code> output is <code>PRVCY</code> from March 2015.</p>
<p>ASCII Identifier Protocols use two multisig configurations:</p>
<ul>
<li>1-of-2: 63.24% of outputs</li>
<li>1-of-3: 36.76% of outputs</li>
</ul>
<p>All 816 ASCII Identifier Protocols P2MS outputs are spendable.</p>
<h3 id="data-storage">Data Storage</h3>
<p>The Data Storage classification captures P2MS transactions where embedded data does not match any known protocol identifier or pattern.
These represent direct data embedding without protocol structure or ASCII identifiers.</p>
<p>The classifier searches for known file signatures (PNG, JPEG, GIF, PDF, ZIP, RAR, GZIP, ZLIB, TAR, and others) via magic byte detection, as well as text content analysis.
However, in practice, the vast majority of data storage outputs contain generic binary or text data without recognisable file signatures; the only file format detected with any frequency is ZLIB-compressed data (90 outputs).
This suggests that early data embedders typically stored raw text, compressed archives, or custom binary formats rather than standard file types like images or PDFs.</p>
<p>Additionally, the classifier identifies proof-of-burn patterns (such as all <code>0xFF</code> or <code>0x00</code> byte pubkeys, or other unspendable patterns) and file metadata patterns (URLs, filenames, archive extensions).</p>
<table>
<thead>
<tr>
<th>Variant</th>
<th align="right">Transactions</th>
<th align="right">Outputs</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>WikiLeaks Cablegate</td>
<td align="right">134</td>
<td align="right">13,362</td>
<td>Diplomatic cables from the WikiLeaks release</td>
</tr>
<tr>
<td>Embedded Data</td>
<td align="right">1,130</td>
<td align="right">10,513</td>
<td>Generic embedded data</td>
</tr>
<tr>
<td>Proof of Burn</td>
<td align="right">4,004</td>
<td align="right">4,004</td>
<td>Outputs used for proof-of-burn mechanisms</td>
</tr>
<tr>
<td>Bitcoin Whitepaper</td>
<td align="right">1</td>
<td align="right">946</td>
<td>Satoshi's Bitcoin whitepaper PDF</td>
</tr>
<tr>
<td>File Metadata</td>
<td align="right">3</td>
<td align="right">5</td>
<td>File metadata or headers embedded in outputs</td>
</tr>
<tr>
<td>Null Data</td>
<td align="right">1</td>
<td align="right">1</td>
<td>Outputs containing null/empty data patterns</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>5,273</strong></td>
<td align="right"><strong>28,831</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Table 23:</strong> Breakdown of Data Storage variants observed in P2MS UTXOs, as of block height 918,997 (14 October 2025).</p>
<p>The "WikiLeaks Cablegate" files dominate this category at 46.3%, representing diplomatic cables embedded across thousands of P2MS outputs.
As explored in <a href="./p2ms-data-carry-1#generic-data-storage">Part 1</a>, this is one of the most famous examples of data storage in P2MS, alongside the Bitcoin whitepaper PDF, which itself was also embedded in April 2013 across 946 P2MS outputs (3.3%).
"Embedded Data" (36.5%) captures various other data embedding efforts.
"Proof of Burn" (13.9%) represents outputs created specifically to demonstrate destruction of bitcoin value.</p>
<p>Data Storage shows diverse multisig configurations, reflecting its ad-hoc nature:</p>
<ul>
<li>1-of-3: 80.84% of outputs</li>
<li>1-of-2: 15.92% of outputs</li>
<li>2-of-2: 1.45% of outputs</li>
<li>1-of-1: 1.28% of outputs</li>
<li>2-of-3: 0.48% of outputs</li>
<li>3-of-3: 0.04% of outputs</li>
</ul>
<p>Only 33.29% of Data Storage P2MS outputs are spendable, with the majority (66.71%) being unspendable due to all keys being used for data carriage or proof-of-burn patterns. ~10.18 BTC is currently locked in Data Storage P2MS outputs.</p>
<h3 id="likely-data-storage">Likely Data Storage</h3>
<p>The Likely Data Storage classification captures P2MS transactions that exhibit characteristics suggesting data storage but lack definitive protocol identifiers or clear data patterns.
Unlike Data Storage (which has confirmed data patterns), Likely Data Storage represents a heuristic-based classification where characteristics such as dust-level values, high output counts, or invalid public keys indicate probable data carriage.</p>
<table>
<thead>
<tr>
<th>Variant</th>
<th align="right">Transactions</th>
<th align="right">Outputs</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dust Amount</td>
<td align="right">1,133</td>
<td align="right">1,367</td>
<td>Outputs with dust-level values suggesting data storage</td>
</tr>
<tr>
<td>High Output Count</td>
<td align="right">67</td>
<td align="right">776</td>
<td>Transactions with many P2MS outputs suggesting bulk data embedding</td>
</tr>
<tr>
<td>Invalid EC Point</td>
<td align="right">8</td>
<td align="right">9</td>
<td>Outputs containing keys that are not valid EC points</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>1,208</strong></td>
<td align="right"><strong>2,152</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Table 24:</strong> Breakdown of Likely Data Storage variants observed in P2MS UTXOs, as of block height 918,997 (14 October 2025).</p>
<p>The dominant variant is "Dust Amount" (63.52%), capturing outputs where the encumbered value is less than 1000 sats.
"High Output Count" (36.06%) identifies transactions that feature 5+ P2MS outputs, a pattern perhaps indicative of bulk data embedding rather than normal multisig usage.
"Invalid EC Point" (0.42%) represents outputs where at least one pubkey is provably not a valid point on the secp256k1 curve, again indicative of data carrying rather than legitimate multisig.</p>
<p>The Likely Data Storage has the following multisig configuration profile:</p>
<ul>
<li>2-of-2: 39.68% of outputs</li>
<li>1-of-1: 32.39% of outputs</li>
<li>1-of-3: 13.89% of outputs</li>
<li>2-of-3: 13.52% of outputs</li>
<li>1-of-2: 0.51% of outputs</li>
</ul>
<p>This distribution is notably different from both Data Storage (e.g., 80.84% 1-of-3) and established data-carrying protocols.
Specifically, 2-of-2 at 39.68% is more commonly associated with legitimate multisig arrangements as opposed to data carriage.</p>
<p>99.86% of Likely Data Storage P2MS outputs are spendable, with only 3 outputs being unspendable.
~0.03 BTC is currently locked in Likely Data Storage outputs.</p>
<h3 id="likely-legitimate-multisig">Likely Legitimate Multisig</h3>
<p>The Likely Legitimate Multisig classification represents P2MS outputs that appear to be genuine multisig arrangements for securing funds rather than data carriage.
These outputs exhibit characteristics consistent with legitimate multisig usage: valid public keys, reasonable value amounts, and multisig configurations that make practical sense for custody arrangements (valid EC point keys).</p>
<table>
<thead>
<tr>
<th>Variant</th>
<th align="right">Transactions</th>
<th align="right">Outputs</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Legitimate Multisig</td>
<td align="right">512</td>
<td align="right">540</td>
<td>Standard multisig outputs with valid keys and reasonable values</td>
</tr>
<tr>
<td>Legitimate Multisig (Null-Padded)</td>
<td align="right">7</td>
<td align="right">7</td>
<td>Multisig outputs with null-padded public keys</td>
</tr>
<tr>
<td>Legitimate Multisig (Duplicate Keys)</td>
<td align="right">5</td>
<td align="right">5</td>
<td>Multisig outputs containing duplicate public keys</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td align="right"><strong>524</strong></td>
<td align="right"><strong>552</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Table 25:</strong> Breakdown of Likely Legitimate Multisig variants observed in P2MS UTXOs, as of block height 918,997 (14 October 2025).</p>
<p>The vast majority (97.8%) are standard legitimate multisig outputs.
The "Null-Padded" variant (1.3%) represents outputs where public keys contain null padding, potentially indicating older wallet software or non-standard key generation.
"Duplicate Keys" (0.9%) captures the unusual case where the same public key appears multiple times in a multisig script, which while technically valid, suggests implementation bugs.</p>
<p>Likely Legitimate Multisig shows the most diverse multisig configuration profile of any classification:</p>
<ul>
<li>2-of-2: 41.30% of outputs</li>
<li>1-of-2: 25.00% of outputs</li>
<li>2-of-3: 12.68% of outputs</li>
<li>1-of-3: 11.41% of outputs</li>
<li>1-of-1: 9.60% of outputs</li>
</ul>
<p>All 552 Likely Legitimate Multisig P2MS outputs are spendable (100%), as would be expected.
The total value locked in these outputs is approximately 6.50 BTC which accounts for ~9.4% of the total value encumbered in P2MS outputs.
This gives an average value of ~0.12 BTC (e.g., 1.2 million sats) per output, which is orders of magnitude higher than Bitcoin Stamps (796 sats) or other data-carrying protocols, clearly a reflection of their use to secure holdings rather than store data.</p>
<p>The fact that only 552 outputs (0.02% of all P2MS UTXOs) appear to represent legitimate multisig usage underscores how completely P2MS has been co-opted for data carriage purposes.</p>
<h2 id="what-to-make-of-all-this">What to make of all this?</h2>
<p>The objective of this analysis has been to present comprehensive data on P2MS usage as observed from P2MS outputs in the UTXO set.
The findings are stark: over 99.98% of P2MS UTXOs serve data embedding protocols, 74.37% are provably unspendable, and just 0.02% (552 of 2.4M outputs) appear to represent legitimate multisig usage.
This represents a fundamental departure from the script type's intended purpose of enabling multisig custody arrangements and is largely driven by one protocol: Bitcoin Stamps.</p>
<h3 id="p2ms-usage-over-time">P2MS usage over time</h3>
<p>Though the content here is centred on P2MS UTXOs, it would be remiss to not consider the totality of P2MS usage, including P2MS outputs that have already been spent.
Figure 7 shows the cumulative number of P2MS outputs created (purple line) versus the cumulative number of P2MS inputs spent (blue line) over time.</p>
<p>Of the ~2.71M P2MS outputs created through to 14 October 2025, approximately 288K have ever been spent as inputs, yielding a spend rate of just 10.6%.
Only ~8% of the spent P2MS outputs were spent in the last ~6 years, with the remaining ~92% having been spent in the ~8 years prior (2012–2020).
Since Bitcoin Stamps launched, the creation of P2MS outputs has vastly outpaced their spending, leading to a growing accumulation of P2MS outputs in the UTXO set.</p>
<p><strong>[Interactive plot - view on website]</strong></p>
<p>Cumulative P2MS inputs (spent) and outputs (created) over time. The dramatic divergence since Bitcoin Stamps launched in early 2023 illustrates that P2MS outputs are being created far faster than they are being spent. Data sourced from <a href="https://mainnet.observer">mainnet.observer</a>.</p>
<h3 id="bitcoin-stamps-permanence">Bitcoin Stamps permanence</h3>
<p>When Bitcoin Stamps launched in early 2023, its creators justified using P2MS on the grounds of permanence and "art": art encoded in deliberately unspendable outputs would remain in the UTXO set indefinitely.
This rationale was controversial, with objection to deliberate UTXO set pollution, but the protocol forged ahead regardless.</p>
<p>It is true that different data carriage techniques offer different persistence guarantees.
Witness data, used by Ordinals/Inscriptions, is not part of the UTXO set and can be pruned by full nodes running in pruned mode.
<code>OP_RETURN</code> outputs are provably unspendable and never enter the UTXO set.
P2MS outputs, however, must be retained by all full nodes because they <em>might</em> be spendable - a node cannot know whether a given public key has a corresponding private key.</p>
<p>Bitcoin Stamps exploits this property by deliberately creating P2MS outputs that are unspendable but appear potentially spendable to the network.
By using invalid Key Burn keys alongside data-carrying keys, Bitcoin Stamps ensures its data remains in the UTXO set of every full node indefinitely.
Each unspendable output adds to the UTXO set size that every full node (archival and pruned) must maintain in fast-access memory.
This is a cost imposed on the entire network.</p>
<p>However, the "permanence guarantee" offered by UTXO set storage is overstated.
While pruned nodes discard block data (including <code>OP_RETURN</code> outputs), over 90% of Bitcoin full nodes (<a href="https://bitnodes.io/nodes/">as of late 2025</a>) run in archival mode, retaining the complete blockchain history.
Data embedded via <code>OP_RETURN</code> is therefore preserved across the vast majority of the network.
Forcing data into the UTXO set, rather than block storage, comes at disproportionate cost to the network with no practical permanence benefit.</p>
<h3 id="bitcoin-core-v30-and-op_return-unbounding">Bitcoin Core v30 and <code>OP_RETURN</code> unbounding</h3>
<p>Bitcoin Core v30.0, released in October 2025, <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-30.0.md#updated-settings">removed the standardness restrictions</a> that previously limited <code>OP_RETURN</code> outputs to 80 bytes of data.
Transactions with <code>OP_RETURN</code> outputs of any size (up to the transaction size limit) are now relayed and mined by default.
This fundamentally changes the data carriage landscape on Bitcoin.</p>
<h3 id="bitcoin-stamps-current-usage-doesnt-justify-p2ms">Bitcoin Stamps' current usage doesn't justify P2MS</h3>
<p>The data shows that Bitcoin Stamps' use case has evolved significantly from its original "art" focus.
As shown in Figure 6, no P2MS "Classic Stamps" (images) have been created since March 2024, and only the JSON-based sub-protocols of Bitcoin Stamps (SRC-20, SRC-101) have leveraged P2MS in 2025.</p>
<p>Bitcoin Stamps' current P2MS usage is entirely for simple JSON payloads, not art.
These JSON payloads do not inherently require the permanence guarantee that P2MS provides.
They could function identically using <code>OP_RETURN</code> outputs, which:</p>
<ul>
<li>Do not pollute the UTXO set (they are provably unspendable and pruned from the UTXO set)</li>
<li>Are now limited in size only by the transaction size limit following the release of Bitcoin Core v30.0</li>
<li>Are the standard, intended mechanism for data carriage on Bitcoin</li>
</ul>
<p>It's worth noting that Bitcoin Stamps already uses multiple data carriage techniques beyond P2MS.
The continued use of P2MS specifically for JSON payloads, when <code>OP_RETURN</code> is now a viable alternative, is difficult to justify.</p>
<h3 id="the-case-for-deprecating-p2ms">The case for deprecating P2MS</h3>
<p>Given the data presented in this analysis, there is a reasonable case for deprecating the creation of new P2MS outputs. That is, introducing a soft fork to make the creation of new P2MS outputs invalid by consensus.</p>
<p>The arguments in favour of deprecation include:</p>
<ol>
<li>
<p><strong>P2MS is not used for its intended purpose.</strong>
The data is unambiguous: 99.98% of P2MS UTXOs serve data embedding protocols, not multisig custody.
Legitimate multisig users migrated to P2SH and P2WSH years ago, which offer better privacy, lower fees, and broader wallet support.
Modern wallets largely do not support P2MS at all; as Bitcoin Core maintainer Ava Chow <a href="https://github.com/bitcoin/bitcoin/pull/28217#issuecomment-1666620826">noted in August 2023</a>: <em>"Bare multisigs are generally unusable to the vast majority of wallet software, if not all of them. They do not have an address type so the vast majority of users are completely unable to send to them."</em></p>
</li>
<li>
<p><strong>The primary user no longer needs P2MS.</strong>
As detailed above, Bitcoin Stamps' current usage is entirely JSON-based sub-protocols that don't require UTXO set permanence.
With <code>OP_RETURN</code> now effectively unbounded, there is no reason for Bitcoin Stamps to continue using P2MS.</p>
</li>
<li>
<p><strong>Reduced maintenance burden.</strong>
Deprecating P2MS would allow Bitcoin Core developers to remove support for a script type that clearly no longer serves its original multisig custody purpose, simplifying the codebase and reducing maintenance overhead.</p>
</li>
<li>
<p><strong>Network resource preservation.</strong>
Preventing new unspendable P2MS outputs would halt the ongoing UTXO set growth from data carriage protocols that now have viable alternatives.</p>
</li>
</ol>
<p>The arguments against deprecation are primarily procedural rather than technical:</p>
<ul>
<li>
<p><strong>Bitcoin's conservatism regarding consensus changes.</strong> Any change that invalidates previously valid transactions requires careful consideration, even if the affected use cases are not the intended purpose.</p>
</li>
<li>
<p><strong>Precedent concerns.</strong> Some argue that restricting how people use Bitcoin, even for purposes such as data carrying via deliberately unspendable transaction outputs, sets a problematic precedent.</p>
</li>
<li>
<p><strong>Existing outputs remain.</strong>
Deprecating new P2MS outputs does nothing about the 2.4M outputs already in the UTXO set.
The pollution that has already occurred is permanent until other change happens in Bitcoin, e.g., a future UTXO set pruning mechanism.</p>
</li>
</ul>
<h3 id="prior-proposals-and-discussions">Prior proposals and discussions</h3>
<p>There have been several proposals to address P2MS misuse, though none have been implemented.</p>
<p>In September 2023, portlandhodl opened Bitcoin Core PR <a href="https://github.com/bitcoin/bitcoin/pull/28400">#28400</a> titled "Make provably unsignable standard P2PK and P2MS outpoints unspendable" to remove provably unspendable P2PK and P2MS transaction outputs from the UTXO set.
The PR received generally positive feedback, with contributors acknowledging the UTXO set pollution problem.</p>
<p>However, it was ultimately closed by the author in March 2024 with the comment: <em>"Closing because the fragility of this PR does not justify its limited impact."</em>
The challenges included determining which outputs are truly provably unspendable, managing consensus implications, and the relatively small impact relative to overall UTXO set size.</p>
<p>A related discussion occurred around PR <a href="https://github.com/bitcoin/bitcoin/pull/28217">#28217</a>, which proposed limiting bare multisig to only <code>OP_CHECKMULTISIG</code> and not <code>OP_CHECKMULTISIGVERIFY</code>.
Developer Jimmy Song <a href="https://twitter.com/jimmysong/status/1735439599055356071">commented in December 2023</a> about the broader question of whether bare multisig should be deprecated entirely, noting the data-carrying abuse.
Various discussions on platforms like <a href="https://stacker.news/items/352806">Stacker News</a> have explored whether P2MS should be made non-standard or removed from consensus, though no such changes have been implemented.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This analysis provides a comprehensive baseline for understanding P2MS usage as of late 2025.
The data demonstrates conclusively that P2MS is no longer serving its intended purpose with data carriage, particularly via Bitcoin Stamps, the dominant use case.
The transition from predominantly spendable outputs before Bitcoin Stamps launched to ~75% unspendable in just ~2.5 years represents a dramatic shift in P2MS usage.</p>
<p>With Bitcoin Core v30.0 removing <code>OP_RETURN</code> size limits, the technical justification for using P2MS as a data carriage mechanism has largely evaporated.
Bitcoin Stamps now has a viable alternative for its JSON-based payloads that doesn't impose permanent costs on the network.
Whether the Bitcoin community chooses to deprecate P2MS, maintain the status quo, or pursue other approaches, the data presented here makes it unambiguously clear that the current state of P2MS usage is far removed from its original design intent.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://research.mempool.space/utxo-set-report/">UTXO Set Report (Mempool Research)</a></li>
<li><a href="https://www.bitmex.com/blog/ordinals-impact-on-node-runners">Ordinals - Impact on Node Runners</a></li>
<li><a href="https://bitcoin.stackexchange.com/questions/23893/what-are-the-limits-of-m-and-n-in-m-of-n-multisig-addresses">What are the limits of m and n in m-of-n multisig addresses?</a></li>
<li><a href="https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-30.0.md">Bitcoin Core v30.0 Release Notes</a></li>
<li><a href="https://github.com/bitcoin/bitcoin/pull/28400">Bitcoin Core PR #28400: Make provably unsignable standard P2PK and P2MS outpoints unspendable</a></li>
<li><a href="https://github.com/bitcoin/bitcoin/pull/28217">Bitcoin Core PR #28217: Limit bare multisig to OP_CHECKMULTISIG</a></li>
<li><a href="https://twitter.com/jimmysong/status/1735439599055356071">Jimmy Song on P2MS deprecation</a></li>
<li><a href="https://stacker.news/items/352806">Stacker News discussion on P2MS standardness</a></li>
</ul>]]></content>
        <author>
            <name>deadmanoz</name>
            <uri>https://deadmanoz.xyz</uri>
        </author>
        <published>2025-12-04T00:00:00.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2MS Data Carry Part 1: Fundamentals and Examples]]></title>
        <id>https://deadmanoz.xyz/posts/p2ms-data-carry-1</id>
        <link href="https://deadmanoz.xyz/posts/p2ms-data-carry-1"/>
        <updated>2025-10-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Examining the techniques of P2MS data carriage]]></summary>
        <content type="html"><![CDATA[<h2 id="tldr">tl;dr</h2>
<p>Pay-to-Multisig (P2MS) is Bitcoin's original multisig format, since superseded by more efficient alternatives like P2SH and P2WSH.
Even so, it persisted - and still persists - as a vehicle for data carriage, with multiple protocols embedding payloads into fake pubkeys inside Bitcoin transactions.
Three major protocols dominate this practice: Bitcoin Stamps, Counterparty and Omni.</p>
<p>Bitcoin Stamps employs ARC4 obfuscation (TXID-keyed) and can be identified by distinctive Key Burn patterns in the original pub keys (<code>0x0222...</code>, <code>0x0333...</code>, etc).
A protocol identifier, e.g., <code>stamp:</code>, appears only once in the deobfuscated key data.
Bitcoin Stamps uses 1-of-3 P2M outputs, with one Key Burn pubkey and two data pubkeys per output, so no private keys exist that can spend the output.</p>
<p>Counterparty also uses ARC4 obfuscation (TXID-keyed) but is identified by the string <code>CNTRPRTY</code> being present in the deobfuscated key data.
The identifier appears once per ARC4-obfuscated output, so multi-output transactions sacrifice data carrying efficiency.
Counterparty maintains at least one real pubkey per output in its 1-of-2 or 1-of-3 configurations, so most Counterparty-related P2MS outputs remain spendable in theory (apart from <a href="#bitcoin-stamps---classic-stamp-image-counterparty-transport">Classic Stamps</a>).</p>
<p>Omni distinguishes itself through obfuscation based on SHA-256+XOR, keyed to the sender's address, and identification via the Exodus address (<code>1EXoDusj...</code>) in adjacent transaction outputs.
Omni also maintains valid pubkeys in its 1-of-2 or 1-of-3 structures, so all Omni P2MS outputs can also be spent (again, in theory).</p>
<p>A number of minor protocols also leverage P2MS for data carrying purposes, including protocols using identifiers such as <code>CHANCECO</code> (Chancecoin), <code>TB0001</code>, <code>TEST01</code> and <code>METROXMN</code>.
Additionally, several protocols employ hybrid approaches that use P2MS alongside <code>OP_RETURN</code>.
PPk (PPkPub) uses the combined data-carrying capacity of P2MS outputs + <code>OP_RETURN</code>, with a distinctive marker pubkey for identification, whereas others use <code>OP_RETURN</code> outputs for explicit protocol signalling with the larger storage capacity of P2MS outputs used for the data payload (e.g., "Protocol 47930", <code>CLIPPERZ</code>).
Beyond protocol-based approaches, P2MS has also been used for generic data storage, with notable examples including the Bitcoin whitepaper PDF and Wikileaks Cablegate files.</p>
<h2 id="introduction">Introduction</h2>
<p>This post is the first in a series of posts that will explore how the Bitcoin blockchain is used for data carriage.
Data carriage refers to the practice of embedding arbitrary, non-financial data into Bitcoin transactions and storing it permanently on the blockchain.
Data carriage is a controversial topic in the Bitcoin community, with some viewing it as a legitimate use case for the blockchain, while others see it as an abuse of the system that adds blockchain bloat and raises costs for everyone.</p>
<p>While there are many ways to embed data in Bitcoin transactions, this and the following posts will explore the use of Pay-to-Multisig (P2MS) script types for data carriage.
This instalment explains the fundamentals of P2MS and how it's used for data carriage while <a href="./p2ms-data-carry-2">Part 2</a> examines the magnitude of P2MS data carriage via an analysis of a snapshot of the UTXO set.
Note that this post goes into detail in breaking down examples of the various protocols; these examples are collapsed by default but can be expanded.</p>
<p>The use of P2MS script types seemed like a good place to start because:</p>
<ul>
<li>It's the legacy script type for multisig that has long been superseded by other script types that enable multisig, including P2SH and P2WSH, with these newer script types being more economical to use.</li>
<li>Given the above, there's no real reason for anyone to use P2MS for multisig, yet it <em>is</em> still used, for data carriage.</li>
<li>There's been a significant increase in P2MS UTXOs since early 2023 as per Figure 1, yet the encumbered value remains <strong>tiny</strong>.</li>
<li>P2MS data carrying is regularly used, albeit much less so than other approaches (e.g., P2TR-based approaches), but it remains understudied compared to other approaches.</li>
</ul>
<p>There have been a number of analyses of data carriage in Bitcoin, but they generally focus on the other data carriage methods.
Pay-to-Fake-Multisig (P2FMS) as the use of P2MS for data carriage is sometimes called, is often just a side note.
See the <a href="#references">References</a> section for links to some of these other analyses.</p>
<p><img src="https://deadmanoz.xyz/assets/blog/p2ms-data-carry/p2ms_analysis.png" alt="Figure 1: the number of P2MS UTXOs and encumbered value over time (block height increments of 50,000)."></p>
<h2 id="p2ms-fundamentals">P2MS fundamentals</h2>
<p>P2MS is a script type that allows users to lock bitcoins to multiple (n) public keys, and require signatures for some or all (m) of those public keys to unlock and spend; an m-of-n multisig.
P2MS is sometimes referred to as raw or bare multisig, as the public keys used to create the lock are directly accessible in the locking script (the <code>ScriptPubKey</code>).
This is in contrast to the more modern multisig constructs of P2SH and P2WSH where the public keys used to create the lock are obfuscated by hashing before being input into the locking script.</p>
<p>Here's an example of a recent transaction from block height <a href="https://mempool.space/block/00000000000000000000708a6447d56220de4d4b2ac7462a6f533d3609320be5">903,379</a> (June 2025) that features two P2MS outputs that are relevant to the following content: <a href="https://mempool.space/tx/eb96a65e4a332f2c84cb847268f614c037e038d2c386eb08d49271966c1b0000">eb96a65e...</a></p>
<p>The <code>ScriptPubKey</code> of the first P2MS output is:</p>
<p><img src="https://deadmanoz.xyz/assets/blog/p2ms-data-carry/mempool.space-p2ms-output.png" alt="Figure 2: the first P2MS output as shown on mempool.space."></p>
<pre><code>512103d587bbd682a301f2933de3efd59ec3aa0e5a305d3b4597a8d71880895ebd9f002102660224cd2ffbf92fada23aa883f0c51f2d55ae13394a40d6538ff2a63d0dce002102020202020202020202020202020202020202020202020202020202020202020253ae
</code></pre>
<p>This <code>ScriptPubKey</code> is 105 bytes, comprised of the following:</p>
<ul>
<li>OP_1 (<code>51</code>), this is m in the m-of-n multisig</li>
<li>3x sets of OP_PUSHBYTES_33 (<code>21</code>) followed by 33-byte public keys
<ul>
<li><code>21 03d587bbd682a301f2933de3efd59ec3aa0e5a305d3b4597a8d71880895ebd9f00</code></li>
<li><code>21 02660224cd2ffbf92fada23aa883f0c51f2d55ae13394a40d6538ff2a63d0dce00</code></li>
<li><code>21 020202020202020202020202020202020202020202020202020202020202020202</code></li>
</ul>
</li>
<li>OP_3 (<code>53</code>), this is n in m-of-n, so it's a 1-of-3 multisig</li>
<li>OP_CHECKMULTISIG (<code>ae</code>)</li>
</ul>
<p>Those first two public keys on the surface look like they could be proper public keys, but that 3rd key looks "fake".
Indeed, even <a href="https://mempool.space/tx/eb96a65e4a332f2c84cb847268f614c037e038d2c386eb08d49271966c1b0000">mempool.space</a> indicates as such, what's the deal with that?</p>
<p><img src="https://deadmanoz.xyz/assets/blog/p2ms-data-carry/mempool.space-p2ms-fake-pubkey.png" alt="Figure 3: mempool.space marking the P2MS as having a fake pubkey."></p>
<h2 id="fake-keys">Fake keys</h2>
<p>The 3rd key is indeed a fake key in the sense that it's not a public key that has a known corresponding private key.
This fake key, <code>020202020202020202020202020202020202020202020202020202020202020202</code>, is actually one of the <em>Key Burn</em> addresses that are used by Bitcoin Stamps, one of the leading data carrying protocols that use P2MS.</p>
<p>The ability to generate predetermined patterns of public keys such as Key Burn addresses in this instance, or burn addresses in general, is almost impossible because it requires generating a private key that leads to the desired public key.
Said another way, the probability of arriving at a pre-determined pattern for an ECC-256 public key is "infinitesimally small to the point where a computer would need to grind away at keys for billions of years in order to produce a valid private key" Bitcoin Stamps.</p>
<p>Because of the near impossibility of generating a private key that leads to a predetermined pattern in a public key, the existence of a highly improbable patterned public key is accepted as evidence that there is no corresponding private key... and that the key cannot be used to spend the output!</p>
<p>According to the <a href="https://github.com/mikeinspace/stamps/blob/main/Key-Burn.md">official Bitcoin Stamps protocol documentation</a>, there are 4 Key Burn addresses/patterns/public keys:</p>
<ul>
<li><code>022222222222222222222222222222222222222222222222222222222222222222</code></li>
<li><code>033333333333333333333333333333333333333333333333333333333333333333</code></li>
<li><code>020202020202020202020202020202020202020202020202020202020202020202</code></li>
<li><code>030303030303030303030303030303030303030303030303030303030303030303</code></li>
</ul>
<p>The Key Burn technique assigns one of the above Key Burn keys to last key position in the 1-of-3 multisig, leaving the first two keys as possibilities to spend the output.</p>
<p>The first two keys, however, are actually the data-carrying component (as we shall later learn from understanding how Bitcoin Stamps works), although we can't always definitively prove that they represent "fake" public keys.
That is, we can run a check to see if a given public key is a valid point on the ECDSA secp256k1 curve, if it is not, we know that it is truly a fake public key, yet if it is a valid point, then it could either be a true key or just "data" that happens to correspond to a point on the curve!</p>
<p>For example, using the 1st and 2nd keys above:</p>
<ul>
<li>1st key: <code>03d587bbd682a301f2933de3efd59ec3aa0e5a305d3b4597a8d71880895ebd9f00</code> is a valid point</li>
<li>2nd key: <code>02660224cd2ffbf92fada23aa883f0c51f2d55ae13394a40d6538ff2a63d0dce00</code> is NOT a valid point</li>
</ul>
<p><strong>CODE: Python code to validate a public key on the secp256k1 curve</strong></p>
<pre><code class="hljs language-python"><span class="hljs-comment"># Validate public key on secp256k1 curve</span>
<span class="hljs-comment"># Returns True if point (x,y) satisfies: y² = x³ + 7 (mod p)</span>

p = <span class="hljs-number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">is_valid_pubkey</span>(<span class="hljs-params">pubkey_hex</span>):
    <span class="hljs-string">"""Check if public key is valid point on secp256k1"""</span>
    pub_bytes = <span class="hljs-built_in">bytes</span>.fromhex(pubkey_hex)

    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pub_bytes) == <span class="hljs-number">33</span>:  <span class="hljs-comment"># Compressed</span>
        prefix, x = pub_bytes[<span class="hljs-number">0</span>], <span class="hljs-built_in">int</span>.from_bytes(pub_bytes[<span class="hljs-number">1</span>:], <span class="hljs-string">'big'</span>)
        y_squared = (<span class="hljs-built_in">pow</span>(x, <span class="hljs-number">3</span>, p) + <span class="hljs-number">7</span>) % p
        y = <span class="hljs-built_in">pow</span>(y_squared, (p + <span class="hljs-number">1</span>) // <span class="hljs-number">4</span>, p)

        <span class="hljs-keyword">if</span> <span class="hljs-built_in">pow</span>(y, <span class="hljs-number">2</span>, p) != y_squared:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

        <span class="hljs-comment"># For any valid x, there are two valid y values: y and p - y</span>
        <span class="hljs-comment"># If calculated y doesn't match prefix parity, use the other root</span>
        <span class="hljs-keyword">if</span> (y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) == (prefix == <span class="hljs-number">0x02</span>):
            y = p - y

        <span class="hljs-keyword">return</span> (y % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) == (prefix == <span class="hljs-number">0x02</span>)

    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(pub_bytes) == <span class="hljs-number">65</span>:  <span class="hljs-comment"># Uncompressed</span>
        x = <span class="hljs-built_in">int</span>.from_bytes(pub_bytes[<span class="hljs-number">1</span>:<span class="hljs-number">33</span>], <span class="hljs-string">'big'</span>)
        y = <span class="hljs-built_in">int</span>.from_bytes(pub_bytes[<span class="hljs-number">33</span>:], <span class="hljs-string">'big'</span>)
        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">pow</span>(y, <span class="hljs-number">2</span>, p) - <span class="hljs-built_in">pow</span>(x, <span class="hljs-number">3</span>, p) - <span class="hljs-number">7</span>) % p == <span class="hljs-number">0</span>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

<span class="hljs-comment"># Usage: is_valid_pubkey("03d587bbd682a301f2933de3efd59ec3aa0e5a305d3b4597a8d71880895ebd9f00")</span>
</code></pre>
<p>Suffice it to say, checking whether a given public key is a valid point on the ECDSA secp256k1 curve is insufficient to definitely prove that the key is data or otherwise - sometimes a public key will be a valid point yet it just represents data (as with the 1st key above).</p>
<p>We have yet to see how keys can represent data; let’s examine how data is embedded.</p>
<h2 id="data-carrying-in-p2ms---a-bitcoin-stamps-example">Data carrying in P2MS - A Bitcoin Stamps example</h2>
<p>Note that the following is provided to give a concrete example of how Bitcoin Stamps embeds arbitrary, non-financial data into Bitcoin transactions; the aim is not to cover the minutiae of how such protocols operate at a higher level (e.g., deploying, minting, transferring etc.).</p>
<p>Bitcoin Stamps inserts data into 1-of-3 P2MS transaction outputs, with the data encoded to look like public keys for the first two keys ("data keys"), and a Key Burn address used for the third.
Setting the Key Burn address aside, with compressed public keys being 33 bytes, the first and last bytes are stripped from each of the data keys, leaving 31 bytes apiece.
Concatenate the byte strings into a single 62-byte string:</p>
<pre><code>d587bbd682a301f2933de3efd59ec3aa0e5a305d3b4597a8d71880895ebd9f + 
660224cd2ffbf92fada23aa883f0c51f2d55ae13394a40d6538ff2a63d0dce
</code></pre>
<p>If the transaction contains two or more P2MS outputs, then the above process is followed for each output: take the first two public keys, disregard the Key Burn, strip bytes and concatenate the data key byte strings.
Then concatenate such strings from each transaction output into a single byte string.</p>
<p>For our example transaction, there's a 2nd multisig output that has the following data keys:</p>
<pre><code>03e34afbaa13450d01f91c6633f7e9cd5893c6096f9087b347a2479c7add951700
02ae587815be570ac6344c49be194daa07e4b8de982f16c8175a981cd0ff4d2200
</code></pre>
<p>Stripped:</p>
<pre><code>e34afbaa13450d01f91c6633f7e9cd5893c6096f9087b347a2479c7add9517 +
ae587815be570ac6344c49be194daa07e4b8de982f16c8175a981cd0ff4d22
</code></pre>
<p>Concatenating the byte string from the first and second output yields the following 124-byte string:</p>
<pre><code>d587bbd682a301f2933de3efd59ec3aa0e5a305d3b4597a8d71880895ebd9f + 
660224cd2ffbf92fada23aa883f0c51f2d55ae13394a40d6538ff2a63d0dce +
e34afbaa13450d01f91c6633f7e9cd5893c6096f9087b347a2479c7add9517 +
ae587815be570ac6344c49be194daa07e4b8de982f16c8175a981cd0ff4d22
</code></pre>
<p>The resulting byte string can now be decoded into meaningful data.
Bitcoin Stamps uses the ARC4 (RC4) stream cipher to obfuscate the original data before embedding it, with a key that is the transaction ID (TXID) corresponding to the first transaction input (<code>vin[0]</code>).
For our example transaction <a href="https://mempool.space/tx/eb96a65e4a332f2c84cb847268f614c037e038d2c386eb08d49271966c1b0000">eb96a65e...</a>, the TXID corresponding to the first transaction input is:</p>
<pre><code>7568f57ecf417e19edefc810f9bbd34d2a62eb770d8492396ceffed3c5dc7348
</code></pre>
<p>Via:</p>
<pre><code>bitcoin-cli getrawtransaction eb96a65e4a332f2c84cb847268f614c037e038d2c386eb08d49271966c1b0000 | xargs bitcoin-cli decoderawtransaction | jq '.vin[0].txid'
</code></pre>
<p>Using <code>7568f57e...</code> as the deobfuscation key, the byte string is deobfuscated to the following.
Note that ARC4 being a stream cipher means that deobfuscation preserves length - 124 bytes in, 124 bytes out.</p>
<pre><code>003f7374616d703a7b2270223a227372632d3230222c226f70223a227472616e73666572222c227469636b223a22424d574b222c22616d74223a2231303030227d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
</code></pre>
<p>The first two bytes, <code>003f</code>, is the length of the decoded data in hex - this is just <code>63</code>.
That is, the 63 bytes following the initial two bytes are the meaningful data, with the remaining data being meaningless (the remaining bytes are zero padding).</p>
<p>Decoding the meaningful 63 bytes with UTF-8 gives:</p>
<pre><code>'stamp:{"p":"src-20","op":"transfer","tick":"BMWK","amt":"1000"}'
</code></pre>
<p>Note that in the above there are no spaces - <a href="https://github.com/stampchain-io/stamps_sdk/blob/main/docs/src20specs.md"><em>"in order to minimize the transaction size spaces are not used in the serialized JSON string which is constructed by the SRC-20 reference wallet"</em></a>.
Prettier formats to the following.</p>
<pre><code class="hljs language-json">stamp<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
	<span class="hljs-attr">"p"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"src-20"</span><span class="hljs-punctuation">,</span>
	<span class="hljs-attr">"op"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"transfer"</span><span class="hljs-punctuation">,</span>
	<span class="hljs-attr">"tick"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"BMWK"</span><span class="hljs-punctuation">,</span>
	<span class="hljs-attr">"amt"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"1000"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>So we've taken the two P2MS transaction outputs and transformed it to the above data.
But we've still got some other aspects of the transaction, such as the two other non-P2MS transaction outputs and the output values, that we should briefly consider.</p>
<h3 id="non-p2ms-transaction-outputs-and-output-values">Non-P2MS transaction outputs and output values</h3>
<p>The first transaction output, <code>vout[0]</code>, with an address <a href="https://mempool.space/address/bc1qmgl3u9m7geanw8tlcydrd8qd44awh2660mpg5a">bc1qmgl3u9m7...</a> is the transfer destination.
Transfer because this is what the <code>op</code> was in this example; in other cases it might be the "minter" or "deployer" etc.
The main point is that <code>vout[0]</code> is always some real address.</p>
<p>The 4th transaction output, <code>vout[3]</code>, with an address <a href="https://mempool.space/address/bc1qdmsmn42qajk7ucmkhcszmcd6g7e3svq0jyx3l5">bc1qdmsmn42q...</a>, is the change address.
In this example, it's actually just the same address that was the single transaction input to this transaction - change is going back to original spending address.</p>
<p>The transaction details in Figure 4 show that the first three outputs have a value of 790 sats each.
I don't think this value has any significance other than it safely exceeds all dust limits - <a href="https://bitcoin.stackexchange.com/questions/10986/what-is-meant-by-bitcoin-dust">the highest being 546 sats for P2PKH for the default configuration of 3 sat/vByte</a>.
That is, these values ensure that each output and thus the overall transaction is valid, yet is low enough to have low monetary value.</p>
<p><img src="https://deadmanoz.xyz/assets/blog/p2ms-data-carry/mempool.space-p2ms-tx-details.png" alt="Figure 4: the transaction details."></p>
<h3 id="unspendable-p2ms-outputs">Unspendable P2MS outputs</h3>
<p>In the above we established that the P2MS transaction outputs were actually purely for data carrying (or were Key Burn) and did not involve real public keys.
As such, these P2MS outputs are effectively unspendable outputs, and, given the current design of Bitcoin, they'll remain in the UTXO set of every Bitcoin node.
Each time there's a transaction that embeds data in P2MS outputs in the manner described above, there will be at least one, but possibly more, new unspendable P2MS UTXOs added to the UTXO set.</p>
<p>Note that this is, perhaps obviously, intentional.
As is noted in the <a href="https://github.com/mikeinspace/stamps/blob/main/BitcoinStamps.md">Bitcoin Stamps documentation</a>:</p>
<blockquote>
<p>"By doing so, the data is preserved in such a manner that is impossible to prune from a full Bitcoin Node, preserving the data immutably forever."</p>
</blockquote>
<p>I think many would consider this wasteful - every time there is some form of individual activity on Bitcoin Stamps, such as the transfer operation from the above example, there's a one-to-one mapping to activity on Bitcoin, tracked forever, by all Bitcoin nodes!
It's probably worth examining Bitcoin Stamps in a bit more detail to better understand the what and why.</p>
<h2 id="bitcoin-stamps">Bitcoin Stamps</h2>
<p>Bitcoin Stamps were developed in response to most NFTs being <em>"merely image pointers to centralized hosting or stored on-chain in prunable witness data"</em>.
They were a means to achieve permanence in <em>"storing art on the blockchain"</em> and indeed STAMP is an acronym for Secure, Tradeable Art Maintained Securely.
The <a href="https://github.com/mikeinspace/stamps/blob/main/BitcoinStamps.md">original spec</a> also stated that Bitcoin Stamps encode:</p>
<blockquote>
<p><em>"an image's binary content to a base64 string, placing this string as a suffix to <code>STAMP:</code> in a transaction's description key, and then broadcasting it using the Counterparty protocol onto the Bitcoin ledger.</em>
<em>The length of the string means that Counterparty defaults to bare multisig, thereby chunking the data into outputs rather than using the limited (and prunable) <code>OP_RETURN</code>.</em>
<em>By doing so, the data is preserved in such a manner that is impossible to prune from a full Bitcoin Node, preserving the data immutably forever."</em></p>
</blockquote>
<p>The above examination of the <a href="https://mempool.space/tx/eb96a65e4a332f2c84cb847268f614c037e038d2c386eb08d49271966c1b0000"><code>eb96a65e...</code></a> transaction is but just one example of Bitcoin Stamps embedding arbitrary data in P2MS outputs.
In fact, Bitcoin Stamps has used a variety of techniques since the first transactions, <a href="https://jpja.github.io/Electrum-Counterparty/decode_tx.html?tx=17686488353b65b128d19031240478ba50f1387d0ea7e5f188ea7fda78ea06f4"><code>17686488...</code></a> and <a href="https://jpja.github.io/Electrum-Counterparty/decode_tx.html?tx=eb3da8146e626b5783f4359fb1510729f4aad923dfac45b6f1f3a2063907147c"><code>eb3da814...</code></a>, were included in Block <a href="https://mempool.space/block/00000000000000000002ea8eb5df114c3f198c7ef5851435e8a4d8e7bd33121c">779,652</a>.</p>
<p>As the above text alluded to, Bitcoin Stamps started out leveraging Counterparty (which has been around since 2014 and is covered in the <a href="#counterparty">Counterparty</a> section).
Specifically, Bitcoin Stamps ("Classic Stamps") were initially a numerical asset on Counterparty, with data encoded via either P2MS or P2WSH.
P2MS Classic Stamps were encoded in the almost the same manner as the example explored above:</p>
<ul>
<li>ARC4 obfuscation/deobfuscation keyed with the TXID of the first transaction input</li>
<li>Key Burn alongside data keys, no real pubkey present</li>
</ul>
<p>However, the deobfuscated data must first contain the <code>CNTRPRTY</code> prefix, followed by some Counterparty message fields, before a <code>STAMP:</code> prefix variant and Bitcoin Stamps specific data is found.
That is, Classic Bitcoin Stamps used Counterparty transactions as a transport mechanism to embed data in Bitcoin transactions.
See <a href="#bitcoin-stamps---classic-stamp-image-counterparty-transport">Bitcoin Stamps - Classic Stamp image (Counterparty transport) example</a> for a breakdown of such a transaction.</p>
<h3 id="bitcoin-stamps-sub-protocols">Bitcoin Stamps sub-protocols</h3>
<p>Since then, Bitcoin Stamps has become or leveraged a suite of sub-protocols or formats, including SRC-20, SRC-101, SRC-721, SRC-721r, OLGA, with each purportedly serving a different purpose.
Note that not all of these forms use P2MS, for example the <a href="https://github.com/mikeinspace/stamps/blob/main/OLGA.md">OLGA Stamp uses P2WSH outputs</a>.
As the interest here is P2MS, we'll only focus on the aspect of Bitcoin Stamps that leverage P2MS: Classic Stamps, SRC-20, SRC-101, SRC-721.</p>
<p>The initial example of Bitcoin Stamps using P2MS above (<a href="#data-carrying-in-p2ms---a-bitcoin-stamps-example">Data carrying in P2MS - A Bitcoin Stamps example</a>) is an example of SRC-20.
SRC-20 was developed in response to the BRC-20 craze of early 2023, with SRC-20 offering stronger permanence guarantees due to use of non-witness transaction data.
Aside: if you're interested in knowing more about BRC-20 and the history of Ordinals and Inscriptions be sure to check out Binance Research's <a href="https://research.binance.com/static/pdf/BRC-20%20Tokens%20-%20A%20Primer.pdf">"BRC-20 Tokens: A Primer" (May 2023)</a> piece.
Most Bitcoin Stamps related Bitcoin transactions involve SRC-20.</p>
<p><a href="https://bitname.gitbook.io/bitname/src-101">SRC-101 is a domain name system native to Bitcoin Stamps</a>, similar to something like the Ethereum Name Service (ENS).
Such systems are, for example, used to replace standard Bitcoin addresses like <code>bc1q34eaj4rz9yxupzxwza2epvt3qv2nvcc0ujqqpl</code> with simple, human-readable names like <code>alice.btc</code>.
The permanence of P2MS, and the guarantee of unspendability via the use of no real pubkeys, were purportedly the rationale for developing SRC-101.</p>
<p>All this is to say that, even within a single ecosystem (Bitcoin Stamps), there are a number of permutations and variants of how data is encoding for data carrying purpose that we need to consider for classification and analysis purposes.</p>
<h3 id="bitcoin-stamps---classic-stamp-image-counterparty-transport">Bitcoin Stamps - Classic Stamp image (Counterparty transport)</h3>
<p><strong>EXAMPLE: Bitcoin Stamps - Classic Stamp image (Counterparty transport)</strong></p>
<p><a href="https://mempool.space/tx/54fdeda90c4573f8a93fa45251a3c6214bcc79aa8549728dfb08ffe3e7dd3d81"><code>54fdeda9...</code></a> is a transaction from block height <a href="https://mempool.space/block/000000000000000000048a022a551b879bd87160c55b22e1f3b9a3d3b2410094">809,193</a> with 79 outputs, 77 of which are P2MS outputs.
A review of the P2MS outputs shows that all have the <code>022222222222222222222222222222222222222222222222222222222222222222</code> Key Burn pattern and the TXID of <code>vin[0]</code> is :</p>
<pre><code>3b2b5e1de60ba341b8ba85e35b09800edb118dc7bee246d54b11420f01aabac5
</code></pre>
<p>Armed with this as the deobfuscation key, we can attempt to decode the data embedded in the 77 P2MS outputs.
Let's examine the first three P2MS outputs to illustrate the process.</p>
<h4 id="1st-p2ms-output">1st P2MS output</h4>
<p>Pubkeys:</p>
<pre><code>02e6e725b168f3eeafa527053d43d06c9569a393c34d0e5c2dad2236b785eaed70
02acb6c9432134cad7242dbbd531c44e5ec5918e31d65adab1b2ffb2d3588c7d36
</code></pre>
<p>Stripped and concatenated:</p>
<pre><code>e6e725b168f3eeafa527053d43d06c9569a393c34d0e5c2dad2236b785eaed +
acb6c9432134cad7242dbbd531c44e5ec5918e31d65adab1b2ffb2d3588c7d
</code></pre>
<p>Deobfuscated with TXID of <code>vin[0]</code>:</p>
<pre><code>3d434e54525052545914575ed3597b0aa71d00000000000000230001005354 +
414d503a52306c474f446c686f41436741504d5041487a4741502f2f2f7777
</code></pre>
<p>ASCII interpretation (some characters replaced with <code>.</code>):</p>
<pre><code>.CNTRPRTY.......STAMP:R0lGODlhoACgAPMPAHzGAP///ww
</code></pre>
<h4 id="2nd-p2ms-output">2nd P2MS output</h4>
<p>Pubkeys:</p>
<pre><code>03e6e725b168f3eeafa5621322e3c853da83f6d2802a4f136cec6c79f0d0e1f8c4
02a690d838397ce3d1252bbffc0eae7961e2b5ba20c759cfb7a384f6cb10ba4bb6
</code></pre>
<p>Stripped and concatenated:</p>
<pre><code>e6e725b168f3eeafa5621322e3c853da83f6d2802a4f136cec6c79f0d0e1f8 +
a690d838397ce3d1252bbffc0eae7961e2b5ba20c759cfb7a384f6cb10ba4b
</code></pre>
<p>Deobfuscated with TXID of <code>vin[0]</code>:</p>
<pre><code>3d434e545250525459514141734144454d48414367414f41416d4f46555841 +
4b6b41414a7845414e426841502b745866747941504b6f41502b6b37674141
</code></pre>
<p>ASCII interpretation:</p>
<pre><code>=CNTRPRTYQAAsADEMHACgAOAAmOFUXAKkAAJxEANBhAP+tXftyAPKoAP+k7gAA
</code></pre>
<h4 id="3rd-p2ms-output">3rd P2MS output</h4>
<p>Pubkeys:</p>
<pre><code>02e6e725b168f3eeafa572112bbfca27aa88e8d58d095f0a6feb4c5f82f2f8ce20
03a8bad838326c8dc13a2f8dfc1fd54c7accea8834ae65c4b19fdbfca4079750c7
</code></pre>
<p>Stripped and concatenated:</p>
<pre><code>e6e725b168f3eeafa572112bbfca27aa88e8d58d095f0a6feb4c5f82f2f8ce +
a8bad838326c8dc13a2f8dfc1fd54c7accea8834ae65c4b19fdbfca4079750
</code></pre>
<p>Deobfuscated with TXID of <code>vin[0]</code>:</p>
<pre><code>3d434e5452505254594143482f4330354656464e44515642464d6934774177 +
4541414141682b5151465a4141504143482b4b55397764476c746158706c5a
</code></pre>
<p>ASCII interpretation:</p>
<pre><code>=CNTRPRTYACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFZAAPACH+KU9wdGltaXplZ
</code></pre>
<p>Whenever we see <code>434e545250525459</code> in deobfuscated output, we have found the <code>CNTRPRTY</code> identifier.
Focusing on the first P2MS output, because we have the <code>CNTRPRTY</code> prefix, we have to interpret the following bytes according to the Counterparty protocol.
Now, depending on whether the transaction represents a "legacy" Counterparty transaction or a "modern" Counterparty transaction, changes the interpretation of data.
Turns out that this is a "modern" form where the message type is a single byte rather than the 4 bytes for "legacy" Counterparty transactions.
Here's a breakdown of the first P2MS output:</p>
<table>
<thead>
<tr>
<th>Byte Position</th>
<th>Hex (or ASCII)</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>3d</code></td>
<td>Length prefix: 61</td>
</tr>
<tr>
<td>1-8</td>
<td><code>434e545250525459</code></td>
<td><code>CNTRPRTY</code> prefix</td>
</tr>
<tr>
<td>9</td>
<td><code>14</code></td>
<td>Message type 20 (Issuance)</td>
</tr>
<tr>
<td>10-17</td>
<td><code>575ed3597b0aa71d</code></td>
<td>Asset ID: 6295701710380377885</td>
</tr>
<tr>
<td>18-25</td>
<td><code>0000000000000023</code></td>
<td>Asset issue amount: 35</td>
</tr>
<tr>
<td>26</td>
<td><code>00</code></td>
<td>Divisible: False</td>
</tr>
<tr>
<td>27</td>
<td><code>01</code></td>
<td>Lock: True</td>
</tr>
<tr>
<td>28</td>
<td><code>00</code></td>
<td>Reset: False</td>
</tr>
<tr>
<td>29-61</td>
<td><code>5354414d503a5230...</code></td>
<td>Description: <code>STAMP:R0lGODlhoACgAPMPAHzGAP///ww</code></td>
</tr>
</tbody>
</table>
<p>Also note that whenever we see <code>5354414d503a</code> or <code>5354414d50533a</code> in the decoded output we have found <code>STAMP:</code> or <code>STAMPS:</code>, respectively (with lowercase variants <code>7374616d703a</code> for <code>stamp:</code> and <code>7374616d70733a</code> for <code>stamps:</code>).
It's the description field where further decoding or interpretation is clearly necessary; we see the <code>STAMP:</code> prefix following by a bunch of random characters.
These random characters are actually <a href="https://github.com/mikeinspace/stamps/blob/main/BitcoinStamps.md#bitcoin-stamps">base64 encoded data of an image</a>:</p>
<blockquote>
<p><em>"encoding an image's binary content to a base64 string, placing this string as a suffix to <code>STAMP:</code> in a transaction's description key, and then broadcasting it using the Counterparty protocol onto the Bitcoin ledger... <code>STAMP:&#x3C;base64 data></code>"</em></p>
</blockquote>
<p>Typically, there would be some "magic bytes" or MIME-type and encoding for image data, but the rationale for the absence of this data in Bitcoin Stamps payloads was <a href="https://github.com/mikeinspace/stamps/blob/main/BitcoinStamps.md#absence-of-mime-type-and-encoding">given as</a>:</p>
<blockquote>
<ul>
<li><em>"The fewer the bytes the better."</em></li>
<li><em>"Given the limited scope of acceptable file formats, we are confident that decoding them accurately based on the base64 string alone is trivial."</em></li>
<li><em>"We are only interested in decoding base64, so if the string does not conform to valid base64 it is rejected.</em>
<em>Therefore, specification of the encoding is unnecessary."</em></li>
</ul>
</blockquote>
<p>Anyway, before we deal with the base64 we need to handle the other P2MS outputs.
It can perhaps be inferred from the 2nd and 3rd P2MS outputs above that each P2MS output will have the <code>CNTRPRTY</code> identifier (prefixed by a length prefix).
That is, each P2MS output has 9 bytes (1 length prefix, 8 <code>CNTRPRTY</code>) reserved for the Counterparty protocol, so the true data carrying capacity is only: (62 - 9)/62 = 85.4%.
This is probably one reason why Bitcoin Stamps opted for a new protocol - improve efficiency by not requiring a length prefix and <code>CNTRPRTY</code> identifier in each P2MS output.</p>
<p>Once we've stripped all length prefixes and <code>CNTRPRTY</code> identifiers from all the deobfuscated P2MS outputs and concatenated them, we end up with 4,004 bytes of base64 data which decodes to a 3,003-byte GIF.
The size discrepancy is base64 encoding overhead: every 4 base64 characters is 3 bytes of binary data, so 4,004 / 4 = 1,001 groups x 3 = 3,003 bytes.
The recovered image is shown in Figure 5.</p>
<p>This example has shown how Bitcoin Stamps created 77 P2MS unspendable outputs in transaction <a href="https://mempool.space/tx/54fdeda90c4573f8a93fa45251a3c6214bcc79aa8549728dfb08ffe3e7dd3d81"><code>54fdeda9...</code></a> for the purpose of storing a single 3kB GIF.</p>
<p><img src="https://deadmanoz.xyz/assets/blog/p2ms-data-carry/54fdeda90c4573f8a93fa45251a3c6214bcc79aa8549728dfb08ffe3e7dd3d81.gif" alt="Figure 5: the GIF embedded in the 77 P2MS outputs of transaction 54fdeda9...."></p>
<h2 id="counterparty">Counterparty</h2>
<p>We began our exploration of data carrying in P2MS with Bitcoin Stamps because this protocol is both the most prolific user of P2MS for data carrying purposes, and is largely the only protocol still in active use today.
It started, however, with Classic Stamps leveraging Counterparty, which was the first protocol to start using P2MS for data carrying purposes in a significant way back in 2014.</p>
<p>We won't dwell much on the history of Counterparty here, it's incredibly well documented elsewhere, including:</p>
<ul>
<li><a href="https://blog.bitmex.com/battle-of-the-dexes/">BitMEX Research - Battle of the Dexes (September 2020)</a></li>
<li><a href="https://blog.bitmex.com/dapps-or-only-bitcoin-transactions-the-2014-debate/">BitMEX Research - The OP_Return Wars of 2014 – Dapps Vs Bitcoin Transactions (July 2022)</a></li>
</ul>
<p>It is, however perhaps worth noting that Counterparty, via the adoption of P2MS for data carrying, was a key factor in the decision <a href="https://bitcoin.org/en/release/v0.9.0#opreturn-and-data-in-the-block-chain">make <code>OP_RETURN</code> transactions standard in Bitcoin Core 0.9.0 (March 2014)</a>:</p>
<blockquote>
<p>"On <code>OP_RETURN</code>: There was been (sic) some confusion and misunderstanding in the community, regarding the <code>OP_RETURN</code> feature in <code>0.9</code> and data in the blockchain.
This change is not an endorsement of storing data in the blockchain.
The <code>OP_RETURN</code> change creates a provably-prunable output, to avoid data storage schemes – some of which were already deployed – that were storing arbitrary data such as images as forever-unspendable TX outputs, bloating bitcoin’s UTXO database."</p>
</blockquote>
<blockquote>
<p>"Storing arbitrary data in the blockchain is still a bad idea; it is less costly and far more efficient to store non-currency data elsewhere."</p>
</blockquote>
<p>Counterparty was created to enable features like user-created tokens (assets), decentralised exchanges ("dexes"), and other financial primitives without requiring changes to the Bitcoin protocol.
By encoding its protocol messages in Bitcoin transactions, Counterparty leveraged Bitcoin's security and immutability to create a financial platform on top of Bitcoin.
The protocol initially used P2MS outputs for data embedding before transitioning to <code>OP_RETURN</code> outputs once they became <em><strong>standard</strong></em>, though P2MS continued to be used for larger transactions that exceeded <code>OP_RETURN</code>'s (standardness) size limits.
Counterparty's approach was influential in demonstrating both the potential and controversy of using Bitcoin for purposes beyond simple value transfer.</p>
<p>Counterparty is also of some importance in being the single largest example of proof-of-burn in Bitcoin.
Proof-of-burn was seen as a way to bootstrap the Counterparty ecosystem without requiring an ICO or pre-mining, which were common practices at the time.
Proof-of-burn involves sending Bitcoin to an unspendable address, effectively "burning" the Bitcoin, and, in the Counterparty case, receiving Counterparty (XCP) tokens in return.
During January 2014, Counterparty distributed XCP tokens to those who sent Bitcoin to the provably unspendable <a href="https://mempool.space/address/1CounterpartyXXXXXXXXXXXXXXXUWLpVr"><code>1CounterpartyXXXXXXXXXXXXXXXUWLpVr</code></a> address.
To date, 2,130.99165372 Bitcoin has been permanently destroyed in being sent to this address.</p>
<h3 id="embedding-counterparty-transactions-in-bitcoin">Embedding Counterparty transactions in Bitcoin</h3>
<p>In general, to know if a transaction involving P2MS outputs is a Counterparty transaction, we actually have to treat the transaction data in a number of different ways.
The majority of Counterparty data is, like Bitcoin Stamps, obfuscated by ARC4, keyed with the TXID of the first input (<code>vin[0]</code>).
However, unlike Bitcoin Stamps, there is no Key Burn key that provides a simple indication that a transaction is a Counterparty transaction; keys in Counterparty are either valid public keys or are data-carrying.</p>
<p>There is a minority of Counterparty transactions that does not, however, use ARC4 obfuscation, and all that is required is simple ASCII decoding.
An example of such is outlined in <a href="#counterparty---no-arc4-obfuscation">Counterparty - no ARC4 obfuscation</a>.</p>
<p>Regardless of whether there is ARC4 obfuscation or not, the definitive indication that a Bitcoin transaction is a Counterparty transaction is if the string <code>CNTRPRTY</code> is present in the data.
For the majority of Counterparty transactions involving ARC4, the deobfuscation process is necessary before <code>CNTRPRTY</code> can be detected, for those lacking ARC4 obfuscation, it is relatively straightforward to identify the <code>CNTRPRTY</code> prefix via ASCII decoding of P2MS data keys.</p>
<p>In addition to there being a mix of data-encoding techniques, Counterparty also (primarily) uses both 1-of-2 and 1-of-3 P2MS transaction outputs.
Depending on which, and when the Counterparty transaction was constructed, the real pubkey is in a different position:</p>
<ul>
<li>for 1-of-2, the real pubkey is the first of the two keys</li>
<li>for 1-of-3, the real pubkey is either the first (newer) or last (older) of the three keys</li>
</ul>
<p>Being a real pubkey, and with each multisig requiring one key to spend, most Counterparty UTXOs can be spent, and thus removed from the UTXO set.
Contrast this with Bitcoin Stamps, where the keys are either Key Burn or data keys thus no private key exists to spend the UTXO, so they will remain in the UTXO set.</p>
<p>The remaining key(s) in each configuration are the data carrying component.
And again, depending on which particular variant of the Counterparty protocol we're dealing with, we may need to strip the first and last bytes from a pubkey like was necessary for Bitcoin Stamps, or no such stripping is required, and entire key encodes data.</p>
<p>The <a href="https://docs.counterparty.io/docs/advanced/protocol/">current, official Counterparty protocol specification</a> states the following:</p>
<blockquote>
<p><em>For identification purposes, every Counterparty transaction’s ‘data’ field is prefixed by the string <code>CNTRPRTY</code>, encoded in UTF‐8.</em>
<em>This string is long enough that transactions with outputs containing pseudo‐random data cannot be mistaken for valid Counterparty transactions.</em>
<em>In testing (i.e. using the <code>TESTCOIN</code> Counterparty network on any blockchain), this string is ‘XX’.</em></p>
</blockquote>
<blockquote>
<p><em>Counterparty data may be stored in three different types of outputs, or in some combinations of those formats.</em>
<em>All of the data is obfuscated by ARC4 using the transaction identifier (TXID) of the first unspent transaction output (UTXO) as the obfuscation key.</em></p>
</blockquote>
<blockquote>
<p><em>Multi‐signature data outputs are one‐of‐three outputs where the first public key is that of the sender, so that the value of the output is redeemable, and the second two public keys encode the data, zero‐padded and prefixed with a length byte.</em></p>
</blockquote>
<p>The following examples examine a few Counterparty transactions that use some of the various methods described above to encode a variety of data in P2MS transactions.</p>
<h3 id="counterparty---no-arc4-obfuscation">Counterparty - no ARC4 obfuscation</h3>
<p><strong>EXAMPLE: Counterparty - no ARC4 obfuscation</strong></p>
<p>Let's look at an example of a simple Counterparty transaction from block <a href="https://mempool.space/block/0000000000000000c548d152b0873eabd83cfba496bb5dddfb2a639b65bf5e9e">290,929</a>, <a href="https://mempool.space/tx/585f50f12288cd9044705483672fbbddb71dff8198b390b40ab3de30db0a88dd"><code>585f50f1...</code></a> that has a single 1-of-2 P2MS output.
For this transaction, the two keys are:</p>
<ul>
<li><code>02dd842167b625c60c10eda494eadd54df7b30f372d717b946b1912f0ce59dddf6</code></li>
<li><code>1c434e5452505254590000000000000000000000010000000001312d0000000000</code></li>
</ul>
<p>Even from just looking at these keys, it should be pretty obvious that the second is likely not a real pubkey!
If we try to decode this 2nd key as ASCII we can immediately observe <code>CNTRPRTY</code> in the output.
For completeness, breaking it down (using knowledge of Counterparty message structure) we have:</p>
<table>
<thead>
<tr>
<th>Byte Position</th>
<th>Hex</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>1c</code></td>
<td>Padding/length indicator (28)</td>
</tr>
<tr>
<td>1-8</td>
<td><code>434e545250525459</code></td>
<td><code>CNTRPRTY</code> prefix</td>
</tr>
<tr>
<td>9-12</td>
<td><code>00000000</code></td>
<td>Message Type 0 (Basic Send)</td>
</tr>
<tr>
<td>13-20</td>
<td><code>0000000000000001</code></td>
<td>Asset ID 1 (XCP)</td>
</tr>
<tr>
<td>21-28</td>
<td><code>0000000001312d00</code></td>
<td>Quantity: 20,000,000 = 0.2 XCP</td>
</tr>
<tr>
<td>29-32</td>
<td><code>00000000</code></td>
<td>4 null bytes</td>
</tr>
</tbody>
</table>
<h3 id="counterparty---arc4-obfuscation">Counterparty - ARC4 obfuscation</h3>
<p><strong>EXAMPLE: Counterparty - ARC4 obfuscation</strong></p>
<p>Here's an example of another relatively simple Counterparty transaction, this time from block <a href="https://mempool.space/block/0000000000000000102836b6107448289827c7eba93b7c37bc2b144bfc9cfb51">368,602</a>, <a href="https://mempool.space/tx/541e640fbb527c35e0ee32d724efa4a5506c4c52acfba1ebc3b45949780c08a8"><code>541e640f...</code></a>.
This transaction has two 1-of-3 P2MS outputs.
On the question of which key position represents the real pubkey, upon examination it's clear that the last of the three keys in each P2MS output is the real key as we have the same key present in both outputs: <code>0241e401...ee1f</code>).
This is sender's public key, as can be confirmed by examining the <code>ScriptSig</code> of the transaction input in Figure 6 with the key highlighted in yellow.</p>
<p><img src="https://deadmanoz.xyz/assets/blog/p2ms-data-carry/mempool.space-p2ms-counterparty-2.png" alt="Figure 6: Counterparty with ARC4 obfuscation transaction details (541e640f...)."></p>
<p>If we follow a process similar to <a href="#data-carrying-in-p2ms---a-bitcoin-stamps-example">the original Bitcoin Stamps example</a>, we end up with:</p>
<ul>
<li>a deobfuscation key of <code>de3dec665a89228593ffa3c0236dd098a6f9ef6ac698db016f8a3303ce728649</code> (TXID of first input)</li>
<li>a 124-byte string from a concatenation of the stripped keys of <code>026e8c99cf905947...</code> + <code>020b446132ea04f4...</code> + <code>02498c99cf905947...</code> + <code>030b446132ea04f4...</code></li>
</ul>
<p>After ARC4 deobfuscation, each P2MS output contains its own length-prefixed segment with a <code>CNTRPRTY</code> header:</p>
<p><strong>First P2MS output (62 bytes):</strong></p>
<table>
<thead>
<tr>
<th>Byte Position</th>
<th>Hex</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>3d</code></td>
<td>Length prefix: 61 bytes follow</td>
</tr>
<tr>
<td>1-8</td>
<td><code>434e545250525459</code></td>
<td><code>CNTRPRTY</code> prefix</td>
</tr>
<tr>
<td>9-12</td>
<td><code>00000014</code></td>
<td>Message Type: 20 (Issuance)</td>
</tr>
<tr>
<td>13-20</td>
<td><code>0000036c089131f1</code></td>
<td>Asset ID: 3762535084529</td>
</tr>
<tr>
<td>21-28</td>
<td><code>0000000000000000</code></td>
<td>Quantity (high 8 bytes): 0</td>
</tr>
<tr>
<td>29-36</td>
<td><code>0000000000000000</code></td>
<td>Quantity (low 8 bytes): 0</td>
</tr>
<tr>
<td>37</td>
<td><code>00</code></td>
<td>Divisible: False</td>
</tr>
<tr>
<td>38</td>
<td><code>00</code></td>
<td>Lock/Reset flags</td>
</tr>
<tr>
<td>39-61</td>
<td><code>285341564520555220534f554c2046524f4d2053494e20</code></td>
<td>Description (part 1): "(SAVE UR SOUL FROM SIN " (23 bytes)</td>
</tr>
</tbody>
</table>
<p><strong>Second P2MS output (62 bytes):</strong></p>
<table>
<thead>
<tr>
<th>Byte Position</th>
<th>Hex</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>62</td>
<td><code>1a</code></td>
<td>Length prefix: 26 bytes follow</td>
</tr>
<tr>
<td>63-70</td>
<td><code>434e545250525459</code></td>
<td><code>CNTRPRTY</code> prefix (repeated)</td>
</tr>
<tr>
<td>71-88</td>
<td><code>262049545320434f4e53455155454e434553</code></td>
<td>Description (part 2): "&#x26; ITS CONSEQUENCES" (18 bytes)</td>
</tr>
<tr>
<td>89-123</td>
<td><code>00...</code></td>
<td>Null padding (35 bytes)</td>
</tr>
</tbody>
</table>
<p>The complete Counterparty message is reconstructed by reading each length-prefixed segment, verifying the <code>CNTRPRTY</code> header, and concatenating the following data.
This structure allows messages to span multiple P2MS outputs while maintaining independent validation of each segment.
Associated with this transaction is a vanity address, <a href="https://mempool.space/address/1SaLvationGodsMarveLousGracaLgYQS"><code>1SaLvationGodsMarveLousGracaLgYQS</code></a>, which is the first transaction output.</p>
<p>And, for sake of completeness, here's some links to <a href="https://tokenscan.io/tx/296339">this transaction</a> and <a href="https://tokenscan.io/asset/SALVATION">"asset" (SALVATION)</a>.</p>
<h2 id="omni-formerly-mastercoin">Omni (formerly Mastercoin)</h2>
<p>The Omni Protocol, originally known as Mastercoin, was the pioneering protocol for building a layer on top of Bitcoin - it predated Counterparty!
Created by J.R. Willett and detailed in his January 2012 whitepaper <a href="https://bitcointalk.org/index.php?topic=56901.0">"The Second Bitcoin Whitepaper"</a>, Mastercoin sought to extend Bitcoin's functionality to enable more complex financial instruments and smart property without requiring any modifications to Bitcoin itself.</p>
<p>The project went live in August 2013 via the Mastercoin Crowdsale with MSC tokens generated during the month of August 2013 when individuals sent bitcoin to the Mastercoin (vanity) "Exodus Address": <a href="https://mempool.space/address/1EXoDusjGwvnjZUyKkxZ4UHEf77z6A5S4P"><code>1EXoDusj...</code></a>.
To date, 6,674.36781069 BTC have been sent to this address.</p>
<p>Mastercoin had a somewhat rocky history, check out the June 2014 Forbes article <a href="https://www.forbes.com/sites/kashmirhill/2014/06/03/mastercoin-maidsafe-crowdsale/">The First 'Bitcoin 2.0' Crowd Sale Was A Wildly Successful $7 Million Disaster</a> for some early context, but despite this, it has had a lasting impact on Bitcoin.
Most prominently Tether (USDT) <a href="https://en.wikipedia.org/wiki/Tether_(cryptocurrency)">launched on the Mastercoin protocol as "Realcoin"</a> and, for years, billions of dollars worth of USDT transactions were embedded in Bitcoin's blockchain via Mastercoin/Omni transactions.
Mastercoin was re-branded to Omni in 2015, likely to <a href="https://en.cryptonomist.ch/2024/04/17/mastercoin-crypto-the-story-of-the-communication-protocol-based-on-bitcoin-which-later-became-omni/">cast off some of the negative connotations associated with the Mastercoin project</a>.</p>
<h3 id="embedding-omni-transactions-in-bitcoin">Embedding Omni transactions in Bitcoin</h3>
<p>The Omni protocol specifies three different ways to embed data in the Bitcoin blockchain:</p>
<ol>
<li>Class A transactions - use fake addresses</li>
<li>Class B transactions - use multi-signature transactions</li>
<li>Class C transactions - use <code>OP_RETURN</code> such that Omni Protocol data is completely prunable.
This class was introduced with re-introduction of <code>OP_RETURN</code> in Bitcoin Core in version 0.9.0 (March 2014).</li>
</ol>
<p>The focus here is then on Class B Omni transactions, which are still used to this day for large transactions that do not fit within the (previous) default <code>OP_RETURN</code> policy limit specified by a majority of the network (e.g., 80 bytes).</p>
<p>According to the <a href="https://github.com/OmniLayer/spec/blob/master/OmniSpecification.adoc#64-class-b-transactions-multisig-method">Omni specification</a>, the first pubkey in each Omni transaction P2MS transaction output <em>"should be a valid public key address designated by the sender which may be used to reclaim the bitcoin assigned to the output"</em>.
The remaining key (in a 1-of-2) or keys (in a 1-of-3) must be compressed public keys, where each 33-byte compressed public key encapsulates an Omni Protocol packet.</p>
<p>After stripping the first and last bytes, the first byte of each 31-byte "packet", is a sequence number which is used to order the packets.
This can range between 1 and 255, which implies:</p>
<ul>
<li>There's 30 usable bytes per-packet (per data key) for Omni Protocol transaction data</li>
<li>There's 255 x 30 = 7,650 bytes maximum data storage capacity for each Class B Omni transaction</li>
</ul>
<p>To encode data in each packet, the sender's address is used, where the sender's address is the address that contributed the most input value.
The sender's address must be a P2PKH address, and:</p>
<blockquote>
<p><em>"Obfuscation is performed by SHA256 hashing the sender's address S times (where S is the sequence number) and taking the first 31 bytes of the resulting hash and XORing with the 31-byte Omni packet.</em>
<em>Multiple SHA256 passes are performed against an uppercase hex representation of the previous hash."</em></p>
</blockquote>
<h3 id="omni---single-packet">Omni - Single Packet</h3>
<p><strong>EXAMPLE: Omni - Single Packet</strong></p>
<p><a href="https://mempool.space/tx/0000297bd516c501aa9b143a5eac8adaf457fa78431e844092a7112815411d03"><code>0000297b...</code></a> is an Omni transaction with a single, 1-of-2 P2MS output in block <a href="https://mempool.space/block/00000000000000000f8cd15fe9923051dd231eb46e09c6e082dd859678df8eba">323,250</a>.
It has an uncompressed (65-byte) key as the first pubkey, and a compressed (33-byte) key as the second pubkey.
The first pubkey is the valid pubkey, so this (currently unspent) P2MS output of 5,678 sats could presumably be spent at some point.
The second pubkey encapsulates the single Omni Protocol packet for this Omni transaction.</p>
<p>There are 7 transaction inputs, all are contributed by the <a href="https://mempool.space/address/1MaStErt4XsYHPwfrN9TpgdURLhHTdMenH"><code>1MaStErt4XsYHPwfrN9TpgdURLhHTdMenH</code></a> address, so this is the sender's address.</p>
<p>To decode, we take the sender's address, apply SHA256 once, and obtain the first 31 bytes of the hash result:</p>
<p><code>2c7f68ac457d834fb57a112f3571d63bb6365d4c0523f9f74b298096160a02</code></p>
<p>Taking the second, data carrying pubkey and stripping the first and last bytes yields:</p>
<p><code>2d7f68ac457d834fb67a112f3571da0eb6365d4c0523f9f74b298096160a02</code></p>
<p>XORing these two 31-byte strings results in:</p>
<p><code>01000000000000000300000000000c35000000000000000000000000000000</code></p>
<p>This breaks down to:</p>
<table>
<thead>
<tr>
<th>Byte Position</th>
<th>Hex</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>01</code></td>
<td>Packet sequence number: 1</td>
</tr>
<tr>
<td>1-2</td>
<td><code>0000</code></td>
<td>Transaction version: 0</td>
</tr>
<tr>
<td>3-4</td>
<td><code>0000</code></td>
<td>Transaction type: 0 (simple send)</td>
</tr>
<tr>
<td>5-8</td>
<td><code>00000003</code></td>
<td>Currency ID: 3 (MaidSafeCoin)</td>
</tr>
<tr>
<td>9-16</td>
<td><code>00000000000c3500</code></td>
<td>Amount: 800,000</td>
</tr>
<tr>
<td>17-30</td>
<td><code>00000000000000000000000000000000</code></td>
<td>Padding (unused)</td>
</tr>
</tbody>
</table>
<p><a href="https://omniexplorer.info/properties/production">This is the official list</a> for the mapping between Currency ID value and name.</p>
<h3 id="omni---multi-packet">Omni - Multi Packet</h3>
<p><strong>EXAMPLE: Omni - Multi Packet</strong></p>
<p>A <em>very</em> recent (25 June 2025!) example of an Omni transaction involving multiple P2MS transaction outputs, and thus multiple Omni packets, is <a href="https://mempool.space/tx/153091863886921ab8bf6a7cc17ea99610795522f48b1824d2e417954e466281"><code>15309186...</code></a>.</p>
<p>The main difference from the single packet example above is that for each subsequent pubkey, we need to apply <code>SHA256</code> once more to the sender's address.
So with a sender's address of <code>1D6oYjFVRAETW1Us9oS36YC71gfRw1omZB</code>, and there being 6 P2MS transaction outputs (the first 5 are 1-of-3, the last is a 1-of-2), we have 11 full 32-byte SHA256 results, with the index indicating the number of SHA256 rounds (remembering to convert to uppercase hex representation before each round):</p>
<ol>
<li>x<code>573a09227032f2dde9d2ecf3ffd930d69276754c3bc4343b01c14e0515741fa0</code></li>
<li><code>bc9197079fb1e344370ab8ee984291f1a3721b37901484dfb2079a158adc5e30</code></li>
<li><code>5439114b4688ba1e4e88ecb1454e7b147c886979b2e817082188b083d21fd871</code></li>
<li><code>cba80dd14016ec8be4cb466affa23d09f2418a361dbad0b3cebffcca473a6e90</code></li>
<li><code>834bdf87e79fd15dd54190a478e4f6e9a82a65e5e1220368405099064ad75dfd</code></li>
<li><code>aa5cfb1d38ad07a94a6986d4101082b673465f528c50efd8710bcf5ace2114dd</code></li>
<li><code>aafcd59c4c16f69343db9aac1091e0aa0b672efc66272b74870e84207986c9f5</code></li>
<li><code>9fb030e442bdfd7ee7cd0c2fbbd801381cb49f04ba11bc1c3ab68a435f8b5806</code></li>
<li><code>43fdd5998b69475c6416789a441cb8b897417a8b55cc0e684fe43e295f682bd7</code></li>
<li><code>a1c0f8d8c283565b31db64d205b403fcd96fbb62a6abe25c60a7bb57e751028e</code></li>
<li><code>b2573c41dd7e13da76fa530f1f48a3a1df4217b362c59a8bcead0135905ac09b</code></li>
</ol>
<p>Dropping the last byte of each hash, and then XORing with the first-and-last-byte stripped compressed keys yields the following.
We can see that the data has been successfully deobfuscated as the leading byte, the sequence number, ranges from 1 (<code>01</code>) through 11 (<code>0b</code>).</p>
<ol>
<li><code>010000003202000200000000456475636174696f6e004f7468657200416e75</code></li>
<li><code>02436f696e0068747470733a2f2f75756367612e636f6d2f616e75636f696e</code></li>
<li><code>037768697465706170657200416e75436f696e206973206120736163726564</code></li>
<li><code>042063757272656e637920666f7220706c616e657461727920726562697274</code></li>
<li><code>05682c206261636b656420627920746865204b756b756c6b616e20436f6465</code></li>
<li><code>06782e204974206272696467657320736f756c20736f7665726569676e7479</code></li>
<li><code>072c20626c6f636b636861696e20696e746567726974792c20616e6420636f</code></li>
<li><code>08736d69632072656d656d6272616e636520666f7220616c6c206265696e67</code></li>
<li><code>09732077616c6b696e67207468652070617468206f66207370697269747561</code></li>
<li><code>0a6c206c6967687420616e642067616c616374696320416e756e6e616b6920</code></li>
<li><code>0b656e6c69676874656e6d656e742e00000000035a4e900000000000000000</code></li>
</ol>
<p>Removing sequence numbers, but still accounting for original byte position in the first packet, this breaks down to:</p>
<table>
<thead>
<tr>
<th>Byte Position</th>
<th>Hex</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-2</td>
<td><code>0000</code></td>
<td>Transaction version: 0</td>
</tr>
<tr>
<td>3-4</td>
<td><code>0032</code></td>
<td>Transaction type: 50 (create fixed property)</td>
</tr>
<tr>
<td>5</td>
<td><code>02</code></td>
<td>Ecosystem: 2 (Test Omni)</td>
</tr>
<tr>
<td>6-7</td>
<td><code>0002</code></td>
<td>Property type: 2 (new divisible currency)</td>
</tr>
<tr>
<td>8-11</td>
<td><code>00000000</code></td>
<td>Previous property ID: 0 (new smart property)</td>
</tr>
<tr>
<td>12-20</td>
<td><code>456475636174696f6e</code></td>
<td>Property Category: "Education"</td>
</tr>
<tr>
<td>21</td>
<td><code>00</code></td>
<td>Null terminator for previous string</td>
</tr>
<tr>
<td>22-26</td>
<td><code>4f74686572</code></td>
<td>Property Subcategory: "Other"</td>
</tr>
<tr>
<td>27</td>
<td><code>00</code></td>
<td>Null terminator for previous string</td>
</tr>
</tbody>
</table>
<p>Continuing with the last 3 bytes (28-30, <code>416e75</code>) concatenated to the second packet (sans sequence number):</p>
<table>
<thead>
<tr>
<th>Byte Position</th>
<th>Hex</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>28-30, 1-4</td>
<td><code>416e75</code>+<code>436f696e</code></td>
<td>Property Name: "AnuCoin"</td>
</tr>
<tr>
<td>5</td>
<td><code>00</code></td>
<td>Null terminator for previous string</td>
</tr>
</tbody>
</table>
<p>Next up is the Property URL, which is the remainder of the second packet (6-30) and into the third packet (1-10).
We reach the end when we hit the null terminator <code>00</code> (byte 11).</p>
<table>
<thead>
<tr>
<th>Byte Position</th>
<th>Hex</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>6-30, 1-10</td>
<td><code>68747470...61706572</code></td>
<td>Property URL: "<a href="https://uucga.com/anucoinwhitepaper">https://uucga.com/anucoinwhitepaper</a>"</td>
</tr>
</tbody>
</table>
<p>This is followed by Property Data, which extends from packet 3 through to packet 11, ending at the null terminator (byte 15):</p>
<table>
<thead>
<tr>
<th>Byte Position</th>
<th>Hex</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Many</td>
<td><code>416e7543...656e742e</code></td>
<td>Property Data: "AnuCoin is a sacred currency for planetary rebirth, backed by the Kukulkan Codex. It bridges soul sovereignty, blockchain integrity, and cosmic remembrance for all beings walking the path of spiritual light and galactic Anunnaki enlightenment."</td>
</tr>
<tr>
<td>16-23</td>
<td><code>000000035a4e9000</code></td>
<td>Number of coins: 14,400,000,000</td>
</tr>
</tbody>
</table>
<p>As per the <a href="https://github.com/OmniLayer/spec/blob/master/OmniSpecification.adoc#field-number-of-coins">Omni spec for the number of coins</a> <em>"for divisible coins or tokens, the value in this field is to be divided by 100,000,000"</em>, so there are actually only 144 units of this "AnuCoin".
And the sender was perhaps very impatient for the world to hear about "AnuCoin", significantly over-paying to get the transaction confirmed quickly:</p>
<p><img src="https://deadmanoz.xyz/assets/blog/p2ms-data-carry/mempool.space-p2ms-anucoin.png" alt="Figure 7: 200,000 sat transaction fee for AnuCoin."></p>
<p>Again, by no means being any form of endorsement, <a href="https://omniexplorer.info/asset/2147484218">here are full details</a> relating to this property/asset on Omni.</p>
<h2 id="other-variants-or-protocols">Other variants or protocols</h2>
<p>As documented in <a href="./p2ms-data-carry-2">Part 2</a>, Bitcoin Stamps, Counterparty and Omni are the dominant protocols that utilise P2MS outputs for data carrying purposes, combined accounting for over 98% of P2MS outputs in the UTXO set.
Yet there are other approaches and minor protocols that also use P2MS outputs to carry data:</p>
<ol>
<li><strong>Minor standalone protocols</strong>: Protocols with their own identifiers embedded in P2MS data: PPk (PPkPub), Chancecoin (<code>CHANCECO</code>), <code>TB0001</code>, <code>TEST01</code>, <code>METROXMN</code></li>
<li><strong>Hybrid OP_RETURN signalling</strong>: Protocols that use <code>OP_RETURN</code> for identification alongside P2MS for data storage</li>
<li><strong>Generic data storage</strong>: Direct data embedding without protocol layers</li>
</ol>
<p>These other identifier patterns or protocols can often be simply identified by ASCII interpretation of the P2MS key data, or data of other outputs (<code>OP_RETURN</code>), though sometimes they have binary formats for messages.</p>
<h3 id="ppk-ppkpub">PPk (PPkPub)</h3>
<p>PPk (PPkPub) was a blockchain infrastructure protocol developed by researchers at Beijing University of Posts and Telecommunications between 2016-2019, designed to create a decentralized naming and identity system built on Bitcoin (see <a href="https://github.com/ppkpub/docs/tree/master/English">English documentation</a>).
The protocol appears to have been abandoned since 2019.</p>
<p>The protocol used so-called ODIN (Open Data Index Name) identifiers to reference resources stored in Bitcoin transactions.
The naming structure follows the format <code>ppk:[BTC_BLOCK_HEIGHT].[BTC_TRANS_INDEX]/[DSS]</code>.
For example, <code>ppk:426896.1290/message.txt</code> points to TXID <a href="https://mempool.space/tx/a7fcc7391e2db0fe13b3a12d37fdbdc6138b2c76a9a447020fa92071a64dfe0c"><code>a7fcc739...</code></a> at position 1290 in block <a href="https://mempool.space/block/0000000000000000016b4c3097e5cdef14379670e126dc8aab6a9054ba1af499">426,896</a>, with <code>message.txt</code> as the Data Source Suffix (DSS), which is basically an (optional) resource path.</p>
<p>So given <code>ppk:426896.1290/message.txt</code>, anyone can locate block 426,896, find transaction at position 1290, detect the PPk marker, extract the payload, and decode the message.
This design leverages Bitcoin "blockchain coordinates" (block height, transaction index within block) as a naming system: globally unique (no collision risk), deterministic, independently verifiable (anyone can reconstruct it), decentralised (no central registry), and immutable (unchanging once mined).</p>
<p>ODINs are retroactive identifiers constructed from these "blockchain coordinates" after mining (not embedded beforehand).
When created, PPk transactions contain only the JSON data payload, in the form of title registration (<code>RT</code>), registration information, or message text, split across P2MS and <code>OP_RETURN</code> outputs, plus a distinctive marker pubkey (<code>0320a0de...3e12</code>) at position 2 in the P2MS output.
No block height, transaction index, or ODIN appears in the transaction itself.</p>
<p>Decoders construct the ODIN deterministically by detecting the marker pubkey, extracting the payload from P2MS and <code>OP_RETURN</code> outputs, inferring the resource path from payload type (RT becomes <code>profile.json</code>, registration data becomes, for example, <code>reg_315.txt</code>, messages become <code>message.txt</code>), looking up "blockchain coordinates", and constructing <code>ppk:[height].[index]/[path]</code>.
Data is unobfuscated and directly readable and both 1-of-2 and 1-of-3 multisig configurations are used.</p>
<h3 id="chancecoin">Chancecoin</h3>
<p>Chancecoin was a gambling protocol built on Bitcoin, only active for a short period in 2014, that used P2MS outputs for data carrying purposes in some circumstances.
Like Counterparty, users were required to send bitcoin to a specific address, between certain dates, to obtain "Chancecoin tokens".
In this case the address was <a href="https://mempool.space/address/1ChancecoinXXXXXXXXXXXXXXXXXZELUFD"><code>1ChancecoinXXXXXXXXXXXXXXXXXZELUFD</code></a>.
To date, 480.19571581 BTC have been sent to it.</p>
<p>Key characteristics:</p>
<ul>
<li><code>CHANCECO</code> identifier present in ASCII interpretation, data is not obfuscated</li>
<li>Uses 1-of-2 P2MS outputs, data is in the 2nd pubkey, the 1st is a valid pubkey</li>
<li>Each Chancecoin P2MS output has 32 bytes data carrying capability</li>
<li>Large Chancecoin messages are split across multiple P2MS outputs</li>
<li>Message format: [<code>CHANCECO</code>:8][MessageID:4][Data:variable]</li>
</ul>
<h3 id="ascii-identifier-patterns">ASCII identifier patterns</h3>
<p>Other identifier patterns that have been observed in P2MS outputs in the UTXO set by simple ASCII decoding include <code>TB0001</code>, <code>TEST01</code>, <code>METROXMN</code>.
There doesn't appear to be much information online about these identifiers, with the exception of <code>METROXMN</code> which is associated with <a href="https://bitcointalk.org/index.php?topic=974486.0">Metronotes XMN</a>, which unequivocally appears to be a scam.</p>
<p>Although the identifiers are not obfuscated, the data that follows is likely representing some form of protocol or message format like the other data carrying methods.
In the <a href="https://github.com/deadmanoz/data-carry-research">companion repository</a>, unlike the other protocols discussed here, no attempt has been made to interpret or decode the data beyond the identifier.</p>
<h3 id="op_return-signalling">OP_RETURN signalling</h3>
<p>Some protocols employ a hybrid approach, using <code>OP_RETURN</code> outputs to signal or identify the protocol, while simultaneously using P2MS outputs to carry the actual data payload.
This dual-output pattern provides explicit protocol identification through the <code>OP_RETURN</code> marker, while the larger data carrying capacity of P2MS outputs is used for the message content.
Three distinct variants have been identified in the UTXO set using this approach:</p>
<ul>
<li>"Protocol 47930" (<code>0xbb3a</code> marker) uses a 2-byte <code>OP_RETURN</code> prefix (<code>0xbb3a</code>) alongside 2-of-2 multisig outputs.</li>
<li>"RT Protocol" employs an ASCII <code>RT</code> identifier in its <code>OP_RETURN</code> output, paired with 1-of-2 multisig data storage.</li>
<li>"CLIPPERZ" is a password manager service that used Bitcoin's blockchain for encrypted data backup and notarization, creating <code>OP_RETURN</code> outputs containing <code>CLIPPERZ</code> alongside 2-of-2 multisig outputs.
The <code>OP_RETURN</code> serves as an explicit protocol declaration, avoiding ambiguity in classification, while the P2MS outputs function as the primary data carrier.</li>
</ul>
<h2 id="generic-data-storage">Generic Data Storage</h2>
<p>Data carrying in P2MS outputs need not rely on some standardised protocol and indeed there are many files (documents, images, etc.) and text, encoded, with or without any obfuscation, into P2MS pubkeys.</p>
<p>There are many examples of using P2MS outputs for generic data storage, but perhaps the most famous two are:</p>
<ol>
<li>The Bitcoin Whitepaper PDF - a single transaction</li>
<li>The Wikileaks Cablegate data - uses multiple transactions</li>
</ol>
<p>Both of these examples, and many other instances of Bitcoin transaction data being used for generic data storage are very well documented by Ken Shirriff in <a href="http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html">Hidden surprises in the Bitcoin blockchain and how they are stored: Nelson Mandela, Wikileaks, photos, and Python software</a> and Ciro Santilli in <a href="https://cirosantilli.com/cool-data-embedded-in-the-bitcoin-blockchain">Cool data embedded in the Bitcoin blockchain: Ciro's Bitcoin Inscription Museum</a>.
For the purposes of understanding how P2MS outputs have been used for generic data storage, we'll examine how we can extract the Bitcoin Whitepaper PDF.</p>
<h3 id="the-bitcoin-whitepaper-pdf">The Bitcoin whitepaper PDF</h3>
<p>The following works through the process of extracting the Bitcoin whitepaper PDF from the transaction <a href="https://mempool.space/tx/54e48e5f5c656b26c3bca14a8c95aa583d07ebe84dde3b7dd4a78f4e4186e713"><code>54e48e5f...</code></a> in block 230,009 (April 2013).
Note that this is also documented in various places online, including some elegant one-liners on <a href="https://bitcoin.stackexchange.com/questions/35959/how-is-the-whitepaper-decoded-from-the-blockchain-tx-with-1000x-m-of-n-multisi">Bitcoin Stack Exchange</a></p>
<p><strong>EXAMPLE: Generic Data Storage - The Bitcoin Whitepaper PDF</strong></p>
<p>One of the most famous examples of data embedding in Bitcoin is the Bitcoin whitepaper PDF embedded in transaction <a href="https://mempool.space/tx/54e48e5f5c656b26c3bca14a8c95aa583d07ebe84dde3b7dd4a78f4e4186e713"><code>54e48e5f...</code></a>.
This transaction has 948 outputs, 946 of which are 1-of-3 P2MS outputs, with the remaining two outputs being standard P2PKH outputs.
All pubkeys involved are also 65-byte uncompressed pubkeys, presumably to maximise data carrying capacity.
Unlike the protocol-based approaches we've examined (Bitcoin Stamps, Counterparty, Omni), this is a straightforward generic data storage example with no obfuscation or encryption.</p>
<p>Examining the first output (<code>vout[0]</code>) as in Figure 8 we can see that the 1-of-3 P2MS output uses full 65-byte uncompressed pubkeys.
With uncompressed pubkeys, typically starting with an <code>04</code> prefix, yet none of these keys starting with <code>04</code>, we know that none of these keys are valid pubkeys, and thus this P2MS output is unspendable.
If we were to examine the remaining 945 P2MS outputs, we would see the same pattern: all 3 keys in each output are uncompressed pubkeys, and none of which are valid pubkeys.</p>
<p><img src="https://deadmanoz.xyz/assets/blog/p2ms-data-carry/mempool.space-p2ms-whitepaper-1.png" alt="Figure 8: details of first P2MS output of the Bitcoin whitepaper PDF transaction  (54e48e5f...)."></p>
<p>The extraction is simpler than protocol-based approaches:</p>
<p><strong>Step 1: Extract all pubkey data</strong></p>
<p>For each of the 946 P2MS outputs, concatenate all three 65-byte chunks:</p>
<ul>
<li>Output 0: <code>e4cf0200...</code> + <code>636f6465...</code> + <code>9ba54728...</code> = 195 bytes</li>
<li>Output 1: <code>f4eb5fde...</code> + <code>1f3fe4ab...</code> + <code>7395c3c8...</code> = 195 bytes</li>
<li>...continue for all 946 outputs</li>
<li>Total concatenated data: 946 × 195 = 184,470 bytes</li>
</ul>
<p><strong>Step 2: Detect the file type</strong></p>
<p>Scanning the concatenated data reveals the PDF magic bytes <code>%PDF</code> (hex: <code>25 50 44 46</code>) at a specific offset:</p>
<pre><code>Byte position 0-7:   e4 cf 02 00 06 7d af 13  (8-byte prefix)
Byte position 8-15:  25 50 44 46 2d 31 2e 34  (%PDF-1.4)
</code></pre>
<p><strong>Step 3: Localise the PDF content</strong></p>
<p>The PDF data is located at the following byte positions in the raw data:</p>
<ul>
<li><strong>Byte 8</strong>: <code>%PDF-1.4\n</code> - PDF header starts</li>
<li><strong>Bytes 184,294-184,298</strong>: <code>%%EOF</code> - End-of-file marker (5 bytes: hex <code>25 25 45 4f 46</code>)</li>
<li><strong>Byte 184,299</strong>: <code>\n</code> - Final newline after EOF (hex <code>0a</code>)</li>
<li><strong>Bytes 184,300-184,469</strong>: Null padding (170 bytes)</li>
</ul>
<p><strong>Step 4: Trim leading and trailing data, extract PDF</strong></p>
<ul>
<li><strong>Total bytes to remove</strong>: 178 bytes (8 byte prefix + 170 bytes null padding)</li>
<li><strong>Byte 0</strong>: <code>%PDF-1.4\n</code> - PDF header (8-byte prefix removed, now at position 0)</li>
<li><strong>Bytes 184,286-184,290</strong>: <code>%%EOF</code> - EOF marker (5 bytes)</li>
<li><strong>Byte 184,291</strong>: <code>\n</code> - Final newline (hex <code>0a</code>)</li>
<li><strong>Total size</strong>: 184,292 bytes</li>
</ul>
<p>The final extracted PDF is exactly <strong>184,292 bytes</strong> and can be saved as a valid PDF file.</p>
<p><img src="https://deadmanoz.xyz/assets/blog/p2ms-data-carry/p2ms-whitepaper-cover.png" alt="Figure 9: the first page of the extracted Bitcoin whitepaper PDF."></p>
<h2 id="summarising-the-main-techniques">Summarising the main techniques</h2>
<p>In the post we've explored the main methods of how data is carried in P2MS transaction outputs, including working through examples that showed how the various protocols or methods operate.
The dominant protocols, Bitcoin Stamps, Counterparty, and Omni, account for over 94% of all P2MS UTXOs (as we shall learn in <a href="./p2ms-data-carry-2">Part 2</a>), with the following summarising the key technical distinctions between them.</p>
<p><strong>Protocol identification</strong>: Bitcoin Stamps can often be identified without deobfuscation via Key Burn patterns, while Counterparty requires attempting deobfuscation to find the <code>CNTRPRTY</code> prefix.
Omni transactions are identified by the presence of the Exodus address as one of the transaction outputs.</p>
<p><strong>Obfuscation techniques</strong>: Bitcoin Stamps and Counterparty both use ARC4 stream cipher obfuscation with the input TXID as the key, whereas Omni uses SHA256 hashing with XOR operations (and generic data storage often uses no obfuscation at all, with the data embedded directly in pubkey).</p>
<p><strong>Spendability vs. permanence</strong>: Bitcoin Stamps deliberately creates unspendable outputs in using no real pubkeys, ensuring the data remains in the UTXO set forever.
Counterparty and Omni, by contrast, include a valid pubkey that allows each output to be spent, theoretically enabling UTXO set cleanup (though, in practice, many remain unspent years after being created).</p>
<p><strong>Data density &#x26; efficiency</strong>: All three protocols achieve roughly similar density per pubkey (30-31 usable bytes), though older non-ARC4 obfuscated Counterparty transactions use all 33 bytes of a 33-byte compressed pubkey.
The efficiency of the Counterparty protocol is lower than the other two due to per-output headers (losing 9 bytes per output), Omni achieves decent efficiency by using 30 of 31 bytes of each stripped pubkey (losing 1 byte per pubkey), and Bitcoin Stamps achieves the highest efficiency by using all bytes in 2nd and subsequent P2MS outputs for data.</p>
<table>
<thead>
<tr>
<th></th>
<th>Bitcoin Stamps</th>
<th>Counterparty</th>
<th>Omni</th>
</tr>
</thead>
<tbody>
<tr>
<td>Obfuscation method</td>
<td>ARC4</td>
<td>ARC4</td>
<td>SHA256+XOR</td>
</tr>
<tr>
<td>To deobfuscate</td>
<td>TXID of first TX input (<code>vin[0].txid</code>)</td>
<td>TXID of first TX input (<code>vin[0].txid</code>)</td>
<td>Sender's address (address contributing most value to input)</td>
</tr>
<tr>
<td>Identifier</td>
<td>Key Burn addresses (<code>0x0222...</code>, <code>0x0333...</code>, etc.)</td>
<td><code>CNTRPRTY</code> prefix (after deobfuscation)</td>
<td>Exodus address (<code>1EXoDusj...</code>) as output</td>
</tr>
<tr>
<td>P2MS configuration</td>
<td>1-of-3</td>
<td>1-of-2 or 1-of-3 (mostly)</td>
<td>1-of-2 or 1-of-3 (only)</td>
</tr>
<tr>
<td>Spendability</td>
<td>Unspendable - Key Burn and data keys only</td>
<td>Spendable - real pubkey present</td>
<td>Spendable - real pubkey present</td>
</tr>
<tr>
<td>Data per pubkey</td>
<td>31 bytes (33-byte compressed, strip first/last)</td>
<td>31 or 33 bytes (varies by variant)</td>
<td>30 bytes (31-byte packet minus sequence)</td>
</tr>
<tr>
<td>Data segment</td>
<td>Transport method dependent</td>
<td>Per P2MS output</td>
<td>Per pubkey</td>
</tr>
<tr>
<td>Carrying efficiency of multi-output</td>
<td>~100%</td>
<td>~85%</td>
<td>~97%</td>
</tr>
<tr>
<td>Active period</td>
<td>2023-present</td>
<td>2014-present</td>
<td>2013-present</td>
</tr>
</tbody>
</table>
<p><strong>Table 1:</strong> Comparison of the technical details of the major P2MS-using protocols.</p>
<p>Beyond these three major protocols, we also see P2MS transaction outputs leveraged by minor protocols.
PPk (PPkPub) uses a distinctive hybrid approach with a marker pubkey in P2MS outputs combined with protocol data in <code>OP_RETURN</code> outputs.
Other minor protocols include Chancecoin and projects with identifiers <code>TB0001</code>, <code>TEST01</code> and <code>METROXMN</code>.
Additional hybrid <code>OP_RETURN</code> + P2MS protocols exist, such as "Protocol 47930" (with <code>0xbb3a</code> marker) and <code>CLIPPERZ</code>.
In addition, P2MS transaction outputs have been used for generic data storage, with prominent examples including the Bitcoin whitepaper PDF and the Wikileaks Cablegate files.
Such examples demonstrate that P2MS can be used for arbitrary file storage without any standardised protocol layer.</p>
<h2 id="whats-next">What's next?</h2>
<p>These technical approaches each make different tradeoffs between efficiency, permanence, and network impact.
But understanding the mechanics is only part of the story - the critical question is: what is the actual scale and cumulative impact of these techniques on the Bitcoin network?
<a href="./p2ms-data-carry-2">Part 2</a> analyses historical trends and a snapshot of the UTXO set to quantify the magnitude of P2MS data carriage in Bitcoin.</p>
<p>Also be sure to check out the <a href="https://github.com/deadmanoz/data-carry-research">companion GitHub repo</a> which includes a <code>decode-txid</code> utility that can be used to decode transactions involving P2MS outputs according to various protocol described above (including some support for generic data storage).</p>
<h2 id="references">References</h2>
<h3 id="general">General</h3>
<ul>
<li><a href="https://github.com/deadmanoz/data-carry-research">deadmanoz Data Carry Research (GitHub companion repository)</a></li>
<li><a href="https://en.wikipedia.org/wiki/RC4">ARC4 (RC4)</a></li>
<li><a href="https://github.com/mikeinspace/stamps/blob/main/BitcoinStamps.md">Bitcoin Stamps Protocol Specification</a></li>
<li><a href="https://github.com/mikeinspace/stamps/blob/main/Key-Burn.md">Bitcoin Stamps: Key Burn</a></li>
<li><a href="https://github.com/stampchain-io/btc_stamps">Bitcoin Stamps Indexer</a></li>
<li><a href="https://github.com/stampchain-io/stamps_sdk">Bitcoin Stamps SDK Documentation</a></li>
<li><a href="https://docs.openstamp.io">OpenStamp</a></li>
<li><a href="https://research.binance.com/static/pdf/BRC-20%20Tokens%20-%20A%20Primer.pdf">BRC-20 Tokens: A Primer</a></li>
<li><a href="https://bitcointalk.org/index.php?topic=395761.0">Counterparty - Pioneering Peer-to-Peer Finance - Official Thread</a></li>
<li><a href="https://docs.counterparty.io/docs/advanced/protocol/">Counterparty Protocol Specification</a></li>
<li><a href="https://github.com/CounterpartyXCP/counterparty-core">Counterparty Core</a></li>
<li><a href="https://jpja.github.io/Electrum-Counterparty/decode_tx">Counterparty Decoder</a></li>
<li><a href="https://jpjanssen.com/how-to-reverse-engineer-counterparty-txs/">How to Reverse Engineer Counterparty TX’s</a></li>
<li><a href="https://bitcointalk.org/index.php?topic=265488.0">MasterCoin: New Protocol Layer Starting From “The Exodus Address”</a></li>
<li><a href="https://github.com/OmniLayer/spec/blob/master/OmniSpecification.adoc">Omni Layer Specification (0.7)</a></li>
<li><a href="https://www.forbes.com/sites/kashmirhill/2014/06/03/mastercoin-maidsafe-crowdsale/">The First 'Bitcoin 2.0' Crowd Sale Was A Wildly Successful $7 Million Disaster</a></li>
<li><a href="https://en.cryptonomist.ch/2024/04/17/mastercoin-crypto-the-story-of-the-communication-protocol-based-on-bitcoin-which-later-became-omni/">Mastercoin crypto: the story of the communication protocol based on Bitcoin, which later became Omni</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tether_(cryptocurrency)">Tether (USDT) History</a></li>
<li><a href="http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html">Hidden surprises in the Bitcoin blockchain and how they are stored: Nelson Mandela, Wikileaks, photos, and Python software</a></li>
<li><a href="https://cirosantilli.com/cool-data-embedded-in-the-bitcoin-blockchain">Cool data embedded in the Bitcoin blockchain: Ciro's Bitcoin Inscription Museum</a></li>
</ul>
<h3 id="academic-research">Academic Research</h3>
<ul>
<li><a href="https://digitalcommons.augustana.edu/cscfaculty/1/">Data Insertion in Bitcoin's Blockchain (2017)</a></li>
<li><a href="https://fc18.ifca.ai/preproceedings/6.pdf">A Quantitative Analysis of the Impact of Arbitrary Blockchain Content on Bitcoin (2018)</a></li>
<li><a href="https://www.researchgate.net/publication/323642931_Analysing_blockchains_and_smart_contracts_tools_and_techniques">Analysing blockchains and smart contracts: tools and techniques (2018, PhD thesis)</a></li>
<li><a href="https://iris.unica.it/bitstream/11584/261530/1/main.pdf">A journey into Bitcoin metadata (2019)</a></li>
<li><a href="https://www.blockchainresearchlab.org/wp-content/uploads/2020/03/BRL-Working-Paper-No-7-Dominating-OP-Returns.pdf">Dominating OP Returns: The Impact of Omni and Veriblock on Bitcoin (2020)</a></li>
<li><a href="https://www.researchgate.net/publication/351897792_An_Analysis_of_Data_Hidden_in_Bitcoin_Addresses">An Analysis of Data Hidden In Bitcoin Addresses (2021)</a></li>
<li><a href="https://arxiv.org/pdf/2503.14057">Bitcoin Burn Addresses: Unveiling the Permanent Losses and Their Underlying Causes (2025)</a></li>
</ul>
<h2 id="changelog">Changelog</h2>
<ul>
<li>2025-11-24: Added PPk</li>
</ul>]]></content>
        <author>
            <name>deadmanoz</name>
            <uri>https://deadmanoz.xyz</uri>
        </author>
        <published>2025-10-16T00:00:00.000Z</published>
    </entry>
</feed>